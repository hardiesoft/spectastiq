(function () {
  'use strict';

  var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
  const VIRIDIS = [
    [0.267004, 0.004874, 0.329415],
    [0.268510, 0.009605, 0.335427],
    [0.269944, 0.014625, 0.341379],
    [0.271305, 0.019942, 0.347269],
    [0.272594, 0.025563, 0.353093],
    [0.273809, 0.031497, 0.358853],
    [0.274952, 0.037752, 0.364543],
    [0.276022, 0.044167, 0.370164],
    [0.277018, 0.050344, 0.375715],
    [0.277941, 0.056324, 0.381191],
    [0.278791, 0.062145, 0.386592],
    [0.279566, 0.067836, 0.391917],
    [0.280267, 0.073417, 0.397163],
    [0.280894, 0.078907, 0.402329],
    [0.281446, 0.084320, 0.407414],
    [0.281924, 0.089666, 0.412415],
    [0.282327, 0.094955, 0.417331],
    [0.282656, 0.100196, 0.422160],
    [0.282910, 0.105393, 0.426902],
    [0.283091, 0.110553, 0.431554],
    [0.283197, 0.115680, 0.436115],
    [0.283229, 0.120777, 0.440584],
    [0.283187, 0.125848, 0.444960],
    [0.283072, 0.130895, 0.449241],
    [0.282884, 0.135920, 0.453427],
    [0.282623, 0.140926, 0.457517],
    [0.282290, 0.145912, 0.461510],
    [0.281887, 0.150881, 0.465405],
    [0.281412, 0.155834, 0.469201],
    [0.280868, 0.160771, 0.472899],
    [0.280255, 0.165693, 0.476498],
    [0.279574, 0.170599, 0.479997],
    [0.278826, 0.175490, 0.483397],
    [0.278012, 0.180367, 0.486697],
    [0.277134, 0.185228, 0.489898],
    [0.276194, 0.190074, 0.493001],
    [0.275191, 0.194905, 0.496005],
    [0.274128, 0.199721, 0.498911],
    [0.273006, 0.204520, 0.501721],
    [0.271828, 0.209303, 0.504434],
    [0.270595, 0.214069, 0.507052],
    [0.269308, 0.218818, 0.509577],
    [0.267968, 0.223549, 0.512008],
    [0.266580, 0.228262, 0.514349],
    [0.265145, 0.232956, 0.516599],
    [0.263663, 0.237631, 0.518762],
    [0.262138, 0.242286, 0.520837],
    [0.260571, 0.246922, 0.522828],
    [0.258965, 0.251537, 0.524736],
    [0.257322, 0.256130, 0.526563],
    [0.255645, 0.260703, 0.528312],
    [0.253935, 0.265254, 0.529983],
    [0.252194, 0.269783, 0.531579],
    [0.250425, 0.274290, 0.533103],
    [0.248629, 0.278775, 0.534556],
    [0.246811, 0.283237, 0.535941],
    [0.244972, 0.287675, 0.537260],
    [0.243113, 0.292092, 0.538516],
    [0.241237, 0.296485, 0.539709],
    [0.239346, 0.300855, 0.540844],
    [0.237441, 0.305202, 0.541921],
    [0.235526, 0.309527, 0.542944],
    [0.233603, 0.313828, 0.543914],
    [0.231674, 0.318106, 0.544834],
    [0.229739, 0.322361, 0.545706],
    [0.227802, 0.326594, 0.546532],
    [0.225863, 0.330805, 0.547314],
    [0.223925, 0.334994, 0.548053],
    [0.221989, 0.339161, 0.548752],
    [0.220057, 0.343307, 0.549413],
    [0.218130, 0.347432, 0.550038],
    [0.216210, 0.351535, 0.550627],
    [0.214298, 0.355619, 0.551184],
    [0.212395, 0.359683, 0.551710],
    [0.210503, 0.363727, 0.552206],
    [0.208623, 0.367752, 0.552675],
    [0.206756, 0.371758, 0.553117],
    [0.204903, 0.375746, 0.553533],
    [0.203063, 0.379716, 0.553925],
    [0.201239, 0.383670, 0.554294],
    [0.199430, 0.387607, 0.554642],
    [0.197636, 0.391528, 0.554969],
    [0.195860, 0.395433, 0.555276],
    [0.194100, 0.399323, 0.555565],
    [0.192357, 0.403199, 0.555836],
    [0.190631, 0.407061, 0.556089],
    [0.188923, 0.410910, 0.556326],
    [0.187231, 0.414746, 0.556547],
    [0.185556, 0.418570, 0.556753],
    [0.183898, 0.422383, 0.556944],
    [0.182256, 0.426184, 0.557120],
    [0.180629, 0.429975, 0.557282],
    [0.179019, 0.433756, 0.557430],
    [0.177423, 0.437527, 0.557565],
    [0.175841, 0.441290, 0.557685],
    [0.174274, 0.445044, 0.557792],
    [0.172719, 0.448791, 0.557885],
    [0.171176, 0.452530, 0.557965],
    [0.169646, 0.456262, 0.558030],
    [0.168126, 0.459988, 0.558082],
    [0.166617, 0.463708, 0.558119],
    [0.165117, 0.467423, 0.558141],
    [0.163625, 0.471133, 0.558148],
    [0.162142, 0.474838, 0.558140],
    [0.160665, 0.478540, 0.558115],
    [0.159194, 0.482237, 0.558073],
    [0.157729, 0.485932, 0.558013],
    [0.156270, 0.489624, 0.557936],
    [0.154815, 0.493313, 0.557840],
    [0.153364, 0.497000, 0.557724],
    [0.151918, 0.500685, 0.557587],
    [0.150476, 0.504369, 0.557430],
    [0.149039, 0.508051, 0.557250],
    [0.147607, 0.511733, 0.557049],
    [0.146180, 0.515413, 0.556823],
    [0.144759, 0.519093, 0.556572],
    [0.143343, 0.522773, 0.556295],
    [0.141935, 0.526453, 0.555991],
    [0.140536, 0.530132, 0.555659],
    [0.139147, 0.533812, 0.555298],
    [0.137770, 0.537492, 0.554906],
    [0.136408, 0.541173, 0.554483],
    [0.135066, 0.544853, 0.554029],
    [0.133743, 0.548535, 0.553541],
    [0.132444, 0.552216, 0.553018],
    [0.131172, 0.555899, 0.552459],
    [0.129933, 0.559582, 0.551864],
    [0.128729, 0.563265, 0.551229],
    [0.127568, 0.566949, 0.550556],
    [0.126453, 0.570633, 0.549841],
    [0.125394, 0.574318, 0.549086],
    [0.124395, 0.578002, 0.548287],
    [0.123463, 0.581687, 0.547445],
    [0.122606, 0.585371, 0.546557],
    [0.121831, 0.589055, 0.545623],
    [0.121148, 0.592739, 0.544641],
    [0.120565, 0.596422, 0.543611],
    [0.120092, 0.600104, 0.542530],
    [0.119738, 0.603785, 0.541400],
    [0.119512, 0.607464, 0.540218],
    [0.119423, 0.611141, 0.538982],
    [0.119483, 0.614817, 0.537692],
    [0.119699, 0.618490, 0.536347],
    [0.120081, 0.622161, 0.534946],
    [0.120638, 0.625828, 0.533488],
    [0.121380, 0.629492, 0.531973],
    [0.122312, 0.633153, 0.530398],
    [0.123444, 0.636809, 0.528763],
    [0.124780, 0.640461, 0.527068],
    [0.126326, 0.644107, 0.525311],
    [0.128087, 0.647749, 0.523491],
    [0.130067, 0.651384, 0.521608],
    [0.132268, 0.655014, 0.519661],
    [0.134692, 0.658636, 0.517649],
    [0.137339, 0.662252, 0.515571],
    [0.140210, 0.665859, 0.513427],
    [0.143303, 0.669459, 0.511215],
    [0.146616, 0.673050, 0.508936],
    [0.150148, 0.676631, 0.506589],
    [0.153894, 0.680203, 0.504172],
    [0.157851, 0.683765, 0.501686],
    [0.162016, 0.687316, 0.499129],
    [0.166383, 0.690856, 0.496502],
    [0.170948, 0.694384, 0.493803],
    [0.175707, 0.697900, 0.491033],
    [0.180653, 0.701402, 0.488189],
    [0.185783, 0.704891, 0.485273],
    [0.191090, 0.708366, 0.482284],
    [0.196571, 0.711827, 0.479221],
    [0.202219, 0.715272, 0.476084],
    [0.208030, 0.718701, 0.472873],
    [0.214000, 0.722114, 0.469588],
    [0.220124, 0.725509, 0.466226],
    [0.226397, 0.728888, 0.462789],
    [0.232815, 0.732247, 0.459277],
    [0.239374, 0.735588, 0.455688],
    [0.246070, 0.738910, 0.452024],
    [0.252899, 0.742211, 0.448284],
    [0.259857, 0.745492, 0.444467],
    [0.266941, 0.748751, 0.440573],
    [0.274149, 0.751988, 0.436601],
    [0.281477, 0.755203, 0.432552],
    [0.288921, 0.758394, 0.428426],
    [0.296479, 0.761561, 0.424223],
    [0.304148, 0.764704, 0.419943],
    [0.311925, 0.767822, 0.415586],
    [0.319809, 0.770914, 0.411152],
    [0.327796, 0.773980, 0.406640],
    [0.335885, 0.777018, 0.402049],
    [0.344074, 0.780029, 0.397381],
    [0.352360, 0.783011, 0.392636],
    [0.360741, 0.785964, 0.387814],
    [0.369214, 0.788888, 0.382914],
    [0.377779, 0.791781, 0.377939],
    [0.386433, 0.794644, 0.372886],
    [0.395174, 0.797475, 0.367757],
    [0.404001, 0.800275, 0.362552],
    [0.412913, 0.803041, 0.357269],
    [0.421908, 0.805774, 0.351910],
    [0.430983, 0.808473, 0.346476],
    [0.440137, 0.811138, 0.340967],
    [0.449368, 0.813768, 0.335384],
    [0.458674, 0.816363, 0.329727],
    [0.468053, 0.818921, 0.323998],
    [0.477504, 0.821444, 0.318195],
    [0.487026, 0.823929, 0.312321],
    [0.496615, 0.826376, 0.306377],
    [0.506271, 0.828786, 0.300362],
    [0.515992, 0.831158, 0.294279],
    [0.525776, 0.833491, 0.288127],
    [0.535621, 0.835785, 0.281908],
    [0.545524, 0.838039, 0.275626],
    [0.555484, 0.840254, 0.269281],
    [0.565498, 0.842430, 0.262877],
    [0.575563, 0.844566, 0.256415],
    [0.585678, 0.846661, 0.249897],
    [0.595839, 0.848717, 0.243329],
    [0.606045, 0.850733, 0.236712],
    [0.616293, 0.852709, 0.230052],
    [0.626579, 0.854645, 0.223353],
    [0.636902, 0.856542, 0.216620],
    [0.647257, 0.858400, 0.209861],
    [0.657642, 0.860219, 0.203082],
    [0.668054, 0.861999, 0.196293],
    [0.678489, 0.863742, 0.189503],
    [0.688944, 0.865448, 0.182725],
    [0.699415, 0.867117, 0.175971],
    [0.709898, 0.868751, 0.169257],
    [0.720391, 0.870350, 0.162603],
    [0.730889, 0.871916, 0.156029],
    [0.741388, 0.873449, 0.149561],
    [0.751884, 0.874951, 0.143228],
    [0.762373, 0.876424, 0.137064],
    [0.772852, 0.877868, 0.131109],
    [0.783315, 0.879285, 0.125405],
    [0.793760, 0.880678, 0.120005],
    [0.804182, 0.882046, 0.114965],
    [0.814576, 0.883393, 0.110347],
    [0.824940, 0.884720, 0.106217],
    [0.835270, 0.886029, 0.102646],
    [0.845561, 0.887322, 0.099702],
    [0.855810, 0.888601, 0.097452],
    [0.866013, 0.889868, 0.095953],
    [0.876168, 0.891125, 0.095250],
    [0.886271, 0.892374, 0.095374],
    [0.896320, 0.893616, 0.096335],
    [0.906311, 0.894855, 0.098125],
    [0.916242, 0.896091, 0.100717],
    [0.926106, 0.897330, 0.104071],
    [0.935904, 0.898570, 0.108131],
    [0.945636, 0.899815, 0.112838],
    [0.955300, 0.901065, 0.118128],
    [0.964894, 0.902323, 0.123941],
    [0.974417, 0.903590, 0.130215],
    [0.983868, 0.904867, 0.136897],
    [0.993248, 0.906157, 0.143936],
  ].flat();

  const PLASMA = [
    [0.050383, 0.029803, 0.527975],
    [0.063536, 0.028426, 0.533124],
    [0.075353, 0.027206, 0.538007],
    [0.086222, 0.026125, 0.542658],
    [0.096379, 0.025165, 0.547103],
    [0.105980, 0.024309, 0.551368],
    [0.115124, 0.023556, 0.555468],
    [0.123903, 0.022878, 0.559423],
    [0.132381, 0.022258, 0.563250],
    [0.140603, 0.021687, 0.566959],
    [0.148607, 0.021154, 0.570562],
    [0.156421, 0.020651, 0.574065],
    [0.164070, 0.020171, 0.577478],
    [0.171574, 0.019706, 0.580806],
    [0.178950, 0.019252, 0.584054],
    [0.186213, 0.018803, 0.587228],
    [0.193374, 0.018354, 0.590330],
    [0.200445, 0.017902, 0.593364],
    [0.207435, 0.017442, 0.596333],
    [0.214350, 0.016973, 0.599239],
    [0.221197, 0.016497, 0.602083],
    [0.227983, 0.016007, 0.604867],
    [0.234715, 0.015502, 0.607592],
    [0.241396, 0.014979, 0.610259],
    [0.248032, 0.014439, 0.612868],
    [0.254627, 0.013882, 0.615419],
    [0.261183, 0.013308, 0.617911],
    [0.267703, 0.012716, 0.620346],
    [0.274191, 0.012109, 0.622722],
    [0.280648, 0.011488, 0.625038],
    [0.287076, 0.010855, 0.627295],
    [0.293478, 0.010213, 0.629490],
    [0.299855, 0.009561, 0.631624],
    [0.306210, 0.008902, 0.633694],
    [0.312543, 0.008239, 0.635700],
    [0.318856, 0.007576, 0.637640],
    [0.325150, 0.006915, 0.639512],
    [0.331426, 0.006261, 0.641316],
    [0.337683, 0.005618, 0.643049],
    [0.343925, 0.004991, 0.644710],
    [0.350150, 0.004382, 0.646298],
    [0.356359, 0.003798, 0.647810],
    [0.362553, 0.003243, 0.649245],
    [0.368733, 0.002724, 0.650601],
    [0.374897, 0.002245, 0.651876],
    [0.381047, 0.001814, 0.653068],
    [0.387183, 0.001434, 0.654177],
    [0.393304, 0.001114, 0.655199],
    [0.399411, 0.000859, 0.656133],
    [0.405503, 0.000678, 0.656977],
    [0.411580, 0.000577, 0.657730],
    [0.417642, 0.000564, 0.658390],
    [0.423689, 0.000646, 0.658956],
    [0.429719, 0.000831, 0.659425],
    [0.435734, 0.001127, 0.659797],
    [0.441732, 0.001540, 0.660069],
    [0.447714, 0.002080, 0.660240],
    [0.453677, 0.002755, 0.660310],
    [0.459623, 0.003574, 0.660277],
    [0.465550, 0.004545, 0.660139],
    [0.471457, 0.005678, 0.659897],
    [0.477344, 0.006980, 0.659549],
    [0.483210, 0.008460, 0.659095],
    [0.489055, 0.010127, 0.658534],
    [0.494877, 0.011990, 0.657865],
    [0.500678, 0.014055, 0.657088],
    [0.506454, 0.016333, 0.656202],
    [0.512206, 0.018833, 0.655209],
    [0.517933, 0.021563, 0.654109],
    [0.523633, 0.024532, 0.652901],
    [0.529306, 0.027747, 0.651586],
    [0.534952, 0.031217, 0.650165],
    [0.540570, 0.034950, 0.648640],
    [0.546157, 0.038954, 0.647010],
    [0.551715, 0.043136, 0.645277],
    [0.557243, 0.047331, 0.643443],
    [0.562738, 0.051545, 0.641509],
    [0.568201, 0.055778, 0.639477],
    [0.573632, 0.060028, 0.637349],
    [0.579029, 0.064296, 0.635126],
    [0.584391, 0.068579, 0.632812],
    [0.589719, 0.072878, 0.630408],
    [0.595011, 0.077190, 0.627917],
    [0.600266, 0.081516, 0.625342],
    [0.605485, 0.085854, 0.622686],
    [0.610667, 0.090204, 0.619951],
    [0.615812, 0.094564, 0.617140],
    [0.620919, 0.098934, 0.614257],
    [0.625987, 0.103312, 0.611305],
    [0.631017, 0.107699, 0.608287],
    [0.636008, 0.112092, 0.605205],
    [0.640959, 0.116492, 0.602065],
    [0.645872, 0.120898, 0.598867],
    [0.650746, 0.125309, 0.595617],
    [0.655580, 0.129725, 0.592317],
    [0.660374, 0.134144, 0.588971],
    [0.665129, 0.138566, 0.585582],
    [0.669845, 0.142992, 0.582154],
    [0.674522, 0.147419, 0.578688],
    [0.679160, 0.151848, 0.575189],
    [0.683758, 0.156278, 0.571660],
    [0.688318, 0.160709, 0.568103],
    [0.692840, 0.165141, 0.564522],
    [0.697324, 0.169573, 0.560919],
    [0.701769, 0.174005, 0.557296],
    [0.706178, 0.178437, 0.553657],
    [0.710549, 0.182868, 0.550004],
    [0.714883, 0.187299, 0.546338],
    [0.719181, 0.191729, 0.542663],
    [0.723444, 0.196158, 0.538981],
    [0.727670, 0.200586, 0.535293],
    [0.731862, 0.205013, 0.531601],
    [0.736019, 0.209439, 0.527908],
    [0.740143, 0.213864, 0.524216],
    [0.744232, 0.218288, 0.520524],
    [0.748289, 0.222711, 0.516834],
    [0.752312, 0.227133, 0.513149],
    [0.756304, 0.231555, 0.509468],
    [0.760264, 0.235976, 0.505794],
    [0.764193, 0.240396, 0.502126],
    [0.768090, 0.244817, 0.498465],
    [0.771958, 0.249237, 0.494813],
    [0.775796, 0.253658, 0.491171],
    [0.779604, 0.258078, 0.487539],
    [0.783383, 0.262500, 0.483918],
    [0.787133, 0.266922, 0.480307],
    [0.790855, 0.271345, 0.476706],
    [0.794549, 0.275770, 0.473117],
    [0.798216, 0.280197, 0.469538],
    [0.801855, 0.284626, 0.465971],
    [0.805467, 0.289057, 0.462415],
    [0.809052, 0.293491, 0.458870],
    [0.812612, 0.297928, 0.455338],
    [0.816144, 0.302368, 0.451816],
    [0.819651, 0.306812, 0.448306],
    [0.823132, 0.311261, 0.444806],
    [0.826588, 0.315714, 0.441316],
    [0.830018, 0.320172, 0.437836],
    [0.833422, 0.324635, 0.434366],
    [0.836801, 0.329105, 0.430905],
    [0.840155, 0.333580, 0.427455],
    [0.843484, 0.338062, 0.424013],
    [0.846788, 0.342551, 0.420579],
    [0.850066, 0.347048, 0.417153],
    [0.853319, 0.351553, 0.413734],
    [0.856547, 0.356066, 0.410322],
    [0.859750, 0.360588, 0.406917],
    [0.862927, 0.365119, 0.403519],
    [0.866078, 0.369660, 0.400126],
    [0.869203, 0.374212, 0.396738],
    [0.872303, 0.378774, 0.393355],
    [0.875376, 0.383347, 0.389976],
    [0.878423, 0.387932, 0.386600],
    [0.881443, 0.392529, 0.383229],
    [0.884436, 0.397139, 0.379860],
    [0.887402, 0.401762, 0.376494],
    [0.890340, 0.406398, 0.373130],
    [0.893250, 0.411048, 0.369768],
    [0.896131, 0.415712, 0.366407],
    [0.898984, 0.420392, 0.363047],
    [0.901807, 0.425087, 0.359688],
    [0.904601, 0.429797, 0.356329],
    [0.907365, 0.434524, 0.352970],
    [0.910098, 0.439268, 0.349610],
    [0.912800, 0.444029, 0.346251],
    [0.915471, 0.448807, 0.342890],
    [0.918109, 0.453603, 0.339529],
    [0.920714, 0.458417, 0.336166],
    [0.923287, 0.463251, 0.332801],
    [0.925825, 0.468103, 0.329435],
    [0.928329, 0.472975, 0.326067],
    [0.930798, 0.477867, 0.322697],
    [0.933232, 0.482780, 0.319325],
    [0.935630, 0.487712, 0.315952],
    [0.937990, 0.492667, 0.312575],
    [0.940313, 0.497642, 0.309197],
    [0.942598, 0.502639, 0.305816],
    [0.944844, 0.507658, 0.302433],
    [0.947051, 0.512699, 0.299049],
    [0.949217, 0.517763, 0.295662],
    [0.951344, 0.522850, 0.292275],
    [0.953428, 0.527960, 0.288883],
    [0.955470, 0.533093, 0.285490],
    [0.957469, 0.538250, 0.282096],
    [0.959424, 0.543431, 0.278701],
    [0.961336, 0.548636, 0.275305],
    [0.963203, 0.553865, 0.271909],
    [0.965024, 0.559118, 0.268513],
    [0.966798, 0.564396, 0.265118],
    [0.968526, 0.569700, 0.261721],
    [0.970205, 0.575028, 0.258325],
    [0.971835, 0.580382, 0.254931],
    [0.973416, 0.585761, 0.251540],
    [0.974947, 0.591165, 0.248151],
    [0.976428, 0.596595, 0.244767],
    [0.977856, 0.602051, 0.241387],
    [0.979233, 0.607532, 0.238013],
    [0.980556, 0.613039, 0.234646],
    [0.981826, 0.618572, 0.231287],
    [0.983041, 0.624131, 0.227937],
    [0.984199, 0.629718, 0.224595],
    [0.985301, 0.635330, 0.221265],
    [0.986345, 0.640969, 0.217948],
    [0.987332, 0.646633, 0.214648],
    [0.988260, 0.652325, 0.211364],
    [0.989128, 0.658043, 0.208100],
    [0.989935, 0.663787, 0.204859],
    [0.990681, 0.669558, 0.201642],
    [0.991365, 0.675355, 0.198453],
    [0.991985, 0.681179, 0.195295],
    [0.992541, 0.687030, 0.192170],
    [0.993032, 0.692907, 0.189084],
    [0.993456, 0.698810, 0.186041],
    [0.993814, 0.704741, 0.183043],
    [0.994103, 0.710698, 0.180097],
    [0.994324, 0.716681, 0.177208],
    [0.994474, 0.722691, 0.174381],
    [0.994553, 0.728728, 0.171622],
    [0.994561, 0.734791, 0.168938],
    [0.994495, 0.740880, 0.166335],
    [0.994355, 0.746995, 0.163821],
    [0.994141, 0.753137, 0.161404],
    [0.993851, 0.759304, 0.159092],
    [0.993482, 0.765499, 0.156891],
    [0.993033, 0.771720, 0.154808],
    [0.992505, 0.777967, 0.152855],
    [0.991897, 0.784239, 0.151042],
    [0.991209, 0.790537, 0.149377],
    [0.990439, 0.796859, 0.147870],
    [0.989587, 0.803205, 0.146529],
    [0.988648, 0.809579, 0.145357],
    [0.987621, 0.815978, 0.144363],
    [0.986509, 0.822401, 0.143557],
    [0.985314, 0.828846, 0.142945],
    [0.984031, 0.835315, 0.142528],
    [0.982653, 0.841812, 0.142303],
    [0.981190, 0.848329, 0.142279],
    [0.979644, 0.854866, 0.142453],
    [0.977995, 0.861432, 0.142808],
    [0.976265, 0.868016, 0.143351],
    [0.974443, 0.874622, 0.144061],
    [0.972530, 0.881250, 0.144923],
    [0.970533, 0.887896, 0.145919],
    [0.968443, 0.894564, 0.147014],
    [0.966271, 0.901249, 0.148180],
    [0.964021, 0.907950, 0.149370],
    [0.961681, 0.914672, 0.150520],
    [0.959276, 0.921407, 0.151566],
    [0.956808, 0.928152, 0.152409],
    [0.954287, 0.934908, 0.152921],
    [0.951726, 0.941671, 0.152925],
    [0.949151, 0.948435, 0.152178],
    [0.946602, 0.955190, 0.150328],
    [0.944152, 0.961916, 0.146861],
    [0.941896, 0.968590, 0.140956],
    [0.940015, 0.975158, 0.131326]
  ].flat();
  const INFERNO = [
    [0.001462, 0.000466, 0.013866],
    [0.002267, 0.001270, 0.018570],
    [0.003299, 0.002249, 0.024239],
    [0.004547, 0.003392, 0.030909],
    [0.006006, 0.004692, 0.038558],
    [0.007676, 0.006136, 0.046836],
    [0.009561, 0.007713, 0.055143],
    [0.011663, 0.009417, 0.063460],
    [0.013995, 0.011225, 0.071862],
    [0.016561, 0.013136, 0.080282],
    [0.019373, 0.015133, 0.088767],
    [0.022447, 0.017199, 0.097327],
    [0.025793, 0.019331, 0.105930],
    [0.029432, 0.021503, 0.114621],
    [0.033385, 0.023702, 0.123397],
    [0.037668, 0.025921, 0.132232],
    [0.042253, 0.028139, 0.141141],
    [0.046915, 0.030324, 0.150164],
    [0.051644, 0.032474, 0.159254],
    [0.056449, 0.034569, 0.168414],
    [0.061340, 0.036590, 0.177642],
    [0.066331, 0.038504, 0.186962],
    [0.071429, 0.040294, 0.196354],
    [0.076637, 0.041905, 0.205799],
    [0.081962, 0.043328, 0.215289],
    [0.087411, 0.044556, 0.224813],
    [0.092990, 0.045583, 0.234358],
    [0.098702, 0.046402, 0.243904],
    [0.104551, 0.047008, 0.253430],
    [0.110536, 0.047399, 0.262912],
    [0.116656, 0.047574, 0.272321],
    [0.122908, 0.047536, 0.281624],
    [0.129285, 0.047293, 0.290788],
    [0.135778, 0.046856, 0.299776],
    [0.142378, 0.046242, 0.308553],
    [0.149073, 0.045468, 0.317085],
    [0.155850, 0.044559, 0.325338],
    [0.162689, 0.043554, 0.333277],
    [0.169575, 0.042489, 0.340874],
    [0.176493, 0.041402, 0.348111],
    [0.183429, 0.040329, 0.354971],
    [0.190367, 0.039309, 0.361447],
    [0.197297, 0.038400, 0.367535],
    [0.204209, 0.037632, 0.373238],
    [0.211095, 0.037030, 0.378563],
    [0.217949, 0.036615, 0.383522],
    [0.224763, 0.036405, 0.388129],
    [0.231538, 0.036405, 0.392400],
    [0.238273, 0.036621, 0.396353],
    [0.244967, 0.037055, 0.400007],
    [0.251620, 0.037705, 0.403378],
    [0.258234, 0.038571, 0.406485],
    [0.264810, 0.039647, 0.409345],
    [0.271347, 0.040922, 0.411976],
    [0.277850, 0.042353, 0.414392],
    [0.284321, 0.043933, 0.416608],
    [0.290763, 0.045644, 0.418637],
    [0.297178, 0.047470, 0.420491],
    [0.303568, 0.049396, 0.422182],
    [0.309935, 0.051407, 0.423721],
    [0.316282, 0.053490, 0.425116],
    [0.322610, 0.055634, 0.426377],
    [0.328921, 0.057827, 0.427511],
    [0.335217, 0.060060, 0.428524],
    [0.341500, 0.062325, 0.429425],
    [0.347771, 0.064616, 0.430217],
    [0.354032, 0.066925, 0.430906],
    [0.360284, 0.069247, 0.431497],
    [0.366529, 0.071579, 0.431994],
    [0.372768, 0.073915, 0.432400],
    [0.379001, 0.076253, 0.432719],
    [0.385228, 0.078591, 0.432955],
    [0.391453, 0.080927, 0.433109],
    [0.397674, 0.083257, 0.433183],
    [0.403894, 0.085580, 0.433179],
    [0.410113, 0.087896, 0.433098],
    [0.416331, 0.090203, 0.432943],
    [0.422549, 0.092501, 0.432714],
    [0.428768, 0.094790, 0.432412],
    [0.434987, 0.097069, 0.432039],
    [0.441207, 0.099338, 0.431594],
    [0.447428, 0.101597, 0.431080],
    [0.453651, 0.103848, 0.430498],
    [0.459875, 0.106089, 0.429846],
    [0.466100, 0.108322, 0.429125],
    [0.472328, 0.110547, 0.428334],
    [0.478558, 0.112764, 0.427475],
    [0.484789, 0.114974, 0.426548],
    [0.491022, 0.117179, 0.425552],
    [0.497257, 0.119379, 0.424488],
    [0.503493, 0.121575, 0.423356],
    [0.509730, 0.123769, 0.422156],
    [0.515967, 0.125960, 0.420887],
    [0.522206, 0.128150, 0.419549],
    [0.528444, 0.130341, 0.418142],
    [0.534683, 0.132534, 0.416667],
    [0.540920, 0.134729, 0.415123],
    [0.547157, 0.136929, 0.413511],
    [0.553392, 0.139134, 0.411829],
    [0.559624, 0.141346, 0.410078],
    [0.565854, 0.143567, 0.408258],
    [0.572081, 0.145797, 0.406369],
    [0.578304, 0.148039, 0.404411],
    [0.584521, 0.150294, 0.402385],
    [0.590734, 0.152563, 0.400290],
    [0.596940, 0.154848, 0.398125],
    [0.603139, 0.157151, 0.395891],
    [0.609330, 0.159474, 0.393589],
    [0.615513, 0.161817, 0.391219],
    [0.621685, 0.164184, 0.388781],
    [0.627847, 0.166575, 0.386276],
    [0.633998, 0.168992, 0.383704],
    [0.640135, 0.171438, 0.381065],
    [0.646260, 0.173914, 0.378359],
    [0.652369, 0.176421, 0.375586],
    [0.658463, 0.178962, 0.372748],
    [0.664540, 0.181539, 0.369846],
    [0.670599, 0.184153, 0.366879],
    [0.676638, 0.186807, 0.363849],
    [0.682656, 0.189501, 0.360757],
    [0.688653, 0.192239, 0.357603],
    [0.694627, 0.195021, 0.354388],
    [0.700576, 0.197851, 0.351113],
    [0.706500, 0.200728, 0.347777],
    [0.712396, 0.203656, 0.344383],
    [0.718264, 0.206636, 0.340931],
    [0.724103, 0.209670, 0.337424],
    [0.729909, 0.212759, 0.333861],
    [0.735683, 0.215906, 0.330245],
    [0.741423, 0.219112, 0.326576],
    [0.747127, 0.222378, 0.322856],
    [0.752794, 0.225706, 0.319085],
    [0.758422, 0.229097, 0.315266],
    [0.764010, 0.232554, 0.311399],
    [0.769556, 0.236077, 0.307485],
    [0.775059, 0.239667, 0.303526],
    [0.780517, 0.243327, 0.299523],
    [0.785929, 0.247056, 0.295477],
    [0.791293, 0.250856, 0.291390],
    [0.796607, 0.254728, 0.287264],
    [0.801871, 0.258674, 0.283099],
    [0.807082, 0.262692, 0.278898],
    [0.812239, 0.266786, 0.274661],
    [0.817341, 0.270954, 0.270390],
    [0.822386, 0.275197, 0.266085],
    [0.827372, 0.279517, 0.261750],
    [0.832299, 0.283913, 0.257383],
    [0.837165, 0.288385, 0.252988],
    [0.841969, 0.292933, 0.248564],
    [0.846709, 0.297559, 0.244113],
    [0.851384, 0.302260, 0.239636],
    [0.855992, 0.307038, 0.235133],
    [0.860533, 0.311892, 0.230606],
    [0.865006, 0.316822, 0.226055],
    [0.869409, 0.321827, 0.221482],
    [0.873741, 0.326906, 0.216886],
    [0.878001, 0.332060, 0.212268],
    [0.882188, 0.337287, 0.207628],
    [0.886302, 0.342586, 0.202968],
    [0.890341, 0.347957, 0.198286],
    [0.894305, 0.353399, 0.193584],
    [0.898192, 0.358911, 0.188860],
    [0.902003, 0.364492, 0.184116],
    [0.905735, 0.370140, 0.179350],
    [0.909390, 0.375856, 0.174563],
    [0.912966, 0.381636, 0.169755],
    [0.916462, 0.387481, 0.164924],
    [0.919879, 0.393389, 0.160070],
    [0.923215, 0.399359, 0.155193],
    [0.926470, 0.405389, 0.150292],
    [0.929644, 0.411479, 0.145367],
    [0.932737, 0.417627, 0.140417],
    [0.935747, 0.423831, 0.135440],
    [0.938675, 0.430091, 0.130438],
    [0.941521, 0.436405, 0.125409],
    [0.944285, 0.442772, 0.120354],
    [0.946965, 0.449191, 0.115272],
    [0.949562, 0.455660, 0.110164],
    [0.952075, 0.462178, 0.105031],
    [0.954506, 0.468744, 0.099874],
    [0.956852, 0.475356, 0.094695],
    [0.959114, 0.482014, 0.089499],
    [0.961293, 0.488716, 0.084289],
    [0.963387, 0.495462, 0.079073],
    [0.965397, 0.502249, 0.073859],
    [0.967322, 0.509078, 0.068659],
    [0.969163, 0.515946, 0.063488],
    [0.970919, 0.522853, 0.058367],
    [0.972590, 0.529798, 0.053324],
    [0.974176, 0.536780, 0.048392],
    [0.975677, 0.543798, 0.043618],
    [0.977092, 0.550850, 0.039050],
    [0.978422, 0.557937, 0.034931],
    [0.979666, 0.565057, 0.031409],
    [0.980824, 0.572209, 0.028508],
    [0.981895, 0.579392, 0.026250],
    [0.982881, 0.586606, 0.024661],
    [0.983779, 0.593849, 0.023770],
    [0.984591, 0.601122, 0.023606],
    [0.985315, 0.608422, 0.024202],
    [0.985952, 0.615750, 0.025592],
    [0.986502, 0.623105, 0.027814],
    [0.986964, 0.630485, 0.030908],
    [0.987337, 0.637890, 0.034916],
    [0.987622, 0.645320, 0.039886],
    [0.987819, 0.652773, 0.045581],
    [0.987926, 0.660250, 0.051750],
    [0.987945, 0.667748, 0.058329],
    [0.987874, 0.675267, 0.065257],
    [0.987714, 0.682807, 0.072489],
    [0.987464, 0.690366, 0.079990],
    [0.987124, 0.697944, 0.087731],
    [0.986694, 0.705540, 0.095694],
    [0.986175, 0.713153, 0.103863],
    [0.985566, 0.720782, 0.112229],
    [0.984865, 0.728427, 0.120785],
    [0.984075, 0.736087, 0.129527],
    [0.983196, 0.743758, 0.138453],
    [0.982228, 0.751442, 0.147565],
    [0.981173, 0.759135, 0.156863],
    [0.980032, 0.766837, 0.166353],
    [0.978806, 0.774545, 0.176037],
    [0.977497, 0.782258, 0.185923],
    [0.976108, 0.789974, 0.196018],
    [0.974638, 0.797692, 0.206332],
    [0.973088, 0.805409, 0.216877],
    [0.971468, 0.813122, 0.227658],
    [0.969783, 0.820825, 0.238686],
    [0.968041, 0.828515, 0.249972],
    [0.966243, 0.836191, 0.261534],
    [0.964394, 0.843848, 0.273391],
    [0.962517, 0.851476, 0.285546],
    [0.960626, 0.859069, 0.298010],
    [0.958720, 0.866624, 0.310820],
    [0.956834, 0.874129, 0.323974],
    [0.954997, 0.881569, 0.337475],
    [0.953215, 0.888942, 0.351369],
    [0.951546, 0.896226, 0.365627],
    [0.950018, 0.903409, 0.380271],
    [0.948683, 0.910473, 0.395289],
    [0.947594, 0.917399, 0.410665],
    [0.946809, 0.924168, 0.426373],
    [0.946392, 0.930761, 0.442367],
    [0.946403, 0.937159, 0.458592],
    [0.946903, 0.943348, 0.474970],
    [0.947937, 0.949318, 0.491426],
    [0.949545, 0.955063, 0.507860],
    [0.951740, 0.960587, 0.524203],
    [0.954529, 0.965896, 0.540361],
    [0.957896, 0.971003, 0.556275],
    [0.961812, 0.975924, 0.571925],
    [0.966249, 0.980678, 0.587206],
    [0.971162, 0.985282, 0.602154],
    [0.976511, 0.989753, 0.616760],
    [0.982257, 0.994109, 0.631017],
    [0.988362, 0.998364, 0.644924]
  ].flat();

  const grayscaleInverted = () => {
    const scale = [];
    for (let i = 0; i < 256; i++) {
      let val = 1 - (i / 256);
      //val = Math.pow(val, 2.3);
      scale.push([val, val, val]);
    }
    return scale;
  };
  const GRAYSCALE_INVERTED = grayscaleInverted().flat();
  // More maps: https://github.com/bpostlethwaite/colormap/tree/master/res/res

  // language=GLSL
  const vertexShaderSource = `#version 300 es
in vec4 a_position;
in vec2 a_uv;
uniform highp vec4 u_uv;

mat4 matrix = mat4(
    2.0,  0.0,  0.0,  0.0,
    0.0, -2.0,  0.0,  0.0,
    0.0,  0.0, -1.0,  0.0,
   -1.0,  1.0,  0.0,  1.0
);
out vec2 v_texcoord;

void main() {
  gl_Position = matrix * a_position;
  v_texcoord = a_uv * vec2(1.0, (u_uv.y - u_uv.x)) + vec2(0.0, u_uv.x);
}
`;

  // language=GLSL
  const fragmentShaderSource = `#version 300 es
precision highp float;

in vec2 v_texcoord;
uniform highp vec4 u_uv;

uniform highp sampler2DArray u_colormap;
uniform highp sampler2DArray u_texture;

uniform highp float u_colormap_index;
uniform highp float u_spectrogram_index;
uniform highp vec3 u_crop_y;

// TODO: Probably need to pass in min/max if we want to clamp to selected tracks.
uniform highp float u_scale;

out vec4 outColor;

float map(float value, float min1, float max1, float min2, float max2) {
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

#define INV_LOG_10 0.43429448190325176

void main() {
    float y = v_texcoord.x;
    float x = v_texcoord.y;

    // How much to crop of the top and bottom of the spectrogram (used if the sample rate of the audio was different
    // from the sample rate the FFT was performed at, since that leaves a blank space at the top) 
    float crop_top = u_crop_y.x;
    float crop_bottom = u_crop_y.y;
    float max_zoom = u_crop_y.z;// Stuff max zoom into this array too.
    float max_y_zoom = max_zoom * 0.8;
    float min_range_y = 1.0 / max_zoom;
    float top = u_uv.z;
    float bottom = u_uv.w;
    float range_y = top - bottom;
    float clamped_range_y = max(range_y, min_range_y);
    // Prevent divide by zero
    float pos_y = bottom / max(0.000001, (1.0 - range_y));
    float m_max_zoom = map(clamped_range_y, 1.0, min_range_y, 1.0, 1.0 / max_y_zoom);
    float actual_height = clamped_range_y * (1.0 / m_max_zoom);
    float remainder = 1.0 - actual_height;
    float selected_bottom = remainder * pos_y;
    float selected_top = selected_bottom + actual_height;
    //vec4 overlay_debug_color = vec4(0.0, 0.0, 0.0, 0.0);
    bool above_range = y > selected_top;
    bool below_range = y < selected_bottom;
    bool in_range = y <= selected_top && y >= selected_bottom;

    if (in_range) {
        y = map(y, selected_bottom, selected_top, bottom, top);
        
        // BLUE
        //overlay_debug_color = vec4(0.0, 0.0, 1.0, 0.2);
    } else if (below_range) {
        y = map(y, 0.0, selected_bottom, 0.0, bottom);
        
        // GREEN
        //overlay_debug_color = vec4(0.0, 1.0, 0.0, .2);
    } else if (above_range) {
        y = map(y, selected_top, 1.0, top, 1.0);
        
        // RED
        //overlay_debug_color = vec4(1.0, 0.0, 0.0, 0.2);
    }
    
    y = map(y, 0.0, 1.0, crop_top, crop_bottom);
    vec2 texcoord = vec2(y, x);
    vec4 c = texture(u_texture, vec3(texcoord.x, texcoord.y, u_spectrogram_index));
    float e = INV_LOG_10 * log(c.r);
    float energyNormalised = e * u_scale;
    float norm = energyNormalised * energyNormalised * energyNormalised * energyNormalised * energyNormalised * energyNormalised;
    
    // TODO: Mel scale?
    vec3 colorMapVal = texture(u_colormap, vec3(norm, 0.5, u_colormap_index)).rgb;
    //outColor = vec4(mix(colorMapVal, overlay_debug_color.rgb, overlay_debug_color.a), 1.0);
    outColor = vec4(colorMapVal, 1.0);
}
`;

  // TODO: If there is a long time between swapping from low-res frame to the next hi-res frame, can we cross-fade a blend
  //  between the two in our shader?
  const texturesForContexts = new Map();
  const drawImage$1 = (
    gl,
    program,
    scale,
    left,
    right,
    top,
    bottom,
    cropBottom,
    cropTop,
    spectrogramTextureIndex = 0,
    paletteTextureIndex = 0
  ) => {
    const texture = texturesForContexts.get(gl);
      // Tell WebGL how to convert from clip space to pixels
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    // Clear the canvas
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    const textureLocation = gl.getUniformLocation(program, "u_texture");
    const scaleLocation = gl.getUniformLocation(program, "u_scale");
    const colormapIndexLocation = gl.getUniformLocation(
      program,
      "u_colormap_index"
    );
    const spectrogramImageIndexLocation = gl.getUniformLocation(program, "u_spectrogram_index");
    const colormapLocation = gl.getUniformLocation(program, "u_colormap");
    const cropY = gl.getUniformLocation(program, "u_crop_y");
    // We don't really have UV coords like this, they have to come through as vertex array objects.
    const uvCoords = gl.getUniformLocation(program, "u_uv");

    // normalisation scale log10, and log10 constant for doing log10 in shader
    gl.uniform1f(scaleLocation, 1.0 / Math.log10(scale));
    gl.uniform1f(colormapIndexLocation, paletteTextureIndex);
    gl.uniform1f(spectrogramImageIndexLocation, spectrogramTextureIndex);
    gl.uniform1i(colormapLocation, 0);
    gl.uniform1i(textureLocation, 1);
    cropBottom = 1.0 - cropBottom;
    const maxYZoom = texture.texWidth / (gl.canvas.height / window.devicePixelRatio);
    gl.uniform4fv(uvCoords, new Float32Array([left, right, top, bottom]));
    gl.uniform3fv(cropY, new Float32Array([cropTop, cropBottom, maxYZoom]));
    // draw the quad (2 triangles, 6 vertices)
    const offset = 0;
    const count = 6;
    gl.drawArrays(gl.TRIANGLES, offset, count);
  };

  const mapRange = (value, min1, max1, min2, max2) => {
    return min2 + ((value - min1) * (max2 - min2)) / (max1 - min1);
  };

  const initMainTexture = (gl, texWidth, texHeight) => {
    // Texture array for raw spectrogram textures:
    const hasFloatLinear = !!gl.getExtension("OES_texture_float_linear");
    const texture = gl.createTexture();
    texturesForContexts.set(gl, { texture, texWidth, texHeight });
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (hasFloatLinear) {
      gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    } else {
      gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    }
    const empty =  new Float32Array(new ArrayBuffer(texWidth * 3 * texHeight * 4));// Dummy data;
    gl.texImage3D(
      gl.TEXTURE_2D_ARRAY,
      0, // mip level
      gl.R32F,
      texWidth,
      texHeight,
      2, // Num slices, could be more in the future if we do more clever things to composite partial frames
      0,
      gl.RED,
      gl.FLOAT,
     empty
    );
    return {texture};
  };

  const submitTexture$1 = (gl, index, bitmap, texWidth, texHeight) => {
    let texture;
    if (!texturesForContexts.get(gl)) {
      texture = initMainTexture(gl, texWidth, texHeight);
    } else {
      texture = texturesForContexts.get(gl);
      if (texture.texWidth !== texWidth || texture.texHeight !== texHeight) {
        texture = initMainTexture(gl, texWidth, texHeight);
      }
    }
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, texture.texture);
    gl.texSubImage3D(
      gl.TEXTURE_2D_ARRAY,
      0, // mip level
      0, // x offset
      0, // y offset
      index,
      texWidth,
      texHeight,
      1,
      gl.RED,
      gl.FLOAT,
      bitmap
    );
  };

  const init = (gl) => {
    const hasFloatLinear = !!gl.getExtension("OES_texture_float_linear");
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    const maps = [
      VIRIDIS,
      PLASMA,
      INFERNO,
      GRAYSCALE_INVERTED,
    ];
    const colorMaps = new Float32Array(maps.flat());
    {
      const texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);
      gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      if (hasFloatLinear) {
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      } else {
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      }
      gl.texImage3D(
        gl.TEXTURE_2D_ARRAY,
        0,
        gl.RGB32F,
        maps[0].length / 3,
        1,
        maps.length,
        0,
        gl.RGB,
        gl.FLOAT,
        colorMaps
      );
    }

    // look up where the vertex data needs to go.
    const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
    const uvAttributeLocation = gl.getAttribLocation(program, "a_uv");

    // Create a vertex array object (attribute state)
    const vao = gl.createVertexArray();

    // and make it the one we're currently working with
    gl.bindVertexArray(vao);
    {
      // create the position buffer, make it the current ARRAY_BUFFER
      // and copy in the color values
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      // Put a unit quad in the buffer
      const positions = new Float32Array([
        0,
        0, // Bottom left
        0,
        1, // Top left
        1,
        0, // Bottom right
        1,
        0, // Bottom right
        0,
        1, // Top left
        1,
        1, // Top right
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      // Turn on the attribute
      gl.enableVertexAttribArray(positionAttributeLocation);

      // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
      const size = 2; // 2 components per iteration
      const type = gl.FLOAT; // the data is 32bit floats
      const normalize = false; // don't normalize the data
      const stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
      const offset = 0; // start at the beginning of the buffer
      gl.vertexAttribPointer(
        positionAttributeLocation,
        size,
        type,
        normalize,
        stride,
        offset
      );
    }

    {
      const texcoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
      // Try to remove the zeroth bucket (which often contains high intensity noise)
      const removeZero = 1.0 / 1024.0;
      // Put texcoords in the buffer
      const uvs = new Float32Array([
        1,
        0, // Bottom left
        removeZero,
        0, // Top left
        1,
        1, // Bottom right
        1,
        1, // Bottom right
        removeZero,
        0, // Top right
        removeZero,
        1, // Top left
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);

      // Turn on the attribute
      gl.enableVertexAttribArray(uvAttributeLocation);

      // Tell the attribute how to get data out of texcoordBuffer (ARRAY_BUFFER)
      const size = 2; // 2 components per iteration
      const type = gl.FLOAT; // the data is 32bit floats
      const normalize = true; // convert from 0-255 to 0.0-1.0
      const stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next color
      const offset = 0; // start at the beginning of the buffer
      gl.vertexAttribPointer(
        uvAttributeLocation,
        size,
        type,
        normalize,
        stride,
        offset
      );
      gl.useProgram(program);
    }

    return {
      drawImage: (
        imgIndex,
        scale,
        left,
        right,
        top,
        bottom,
        cropTop,
        cropBottom,
        colorMapIndex
      ) =>
        drawImage$1(
          gl,
          program,
          scale,
          left,
          right,
          top,
          bottom,
          cropTop,
          cropBottom,
          imgIndex,
          colorMapIndex
        ),
      submitTexture: (index, bitmap, width, height) => submitTexture$1(gl, index, bitmap, width, height)
    };
    // Unlike images, textures do not have a width and height associated
    // with them so we'll pass in the width and height of the texture
  };

  const getMaxXZoom = (canvasWidth, state) => {
    const audioSamples = state.numAudioSamples;
    if (audioSamples) {
      // About 180 samples per pixel looks about max res at FFT size of 2048
      return (audioSamples / canvasWidth / 180) * window.devicePixelRatio;
    } else {
      return 16;
    }
  };

  const getMaxYZoom = (canvasHeight) => {
    const FFT_WINDOW_SIZE = 2048;
    const frequencyResolution = FFT_WINDOW_SIZE / 2;
    // About 180 samples per pixel looks about max res at FFT size of 2048
    return frequencyResolution / canvasHeight; // * window.devicePixelRatio;
  };

  const setInitialZoom = (
    left,
    right,
    top,
    bottom,
    state,
    sharedState,
    timelineElements,
    initial,
    final
  ) => {
    // Update zoom level
    const zoomXLength = right - left;
    const zoomXToSet = 1 / zoomXLength;
    const zoomYLength = top - bottom;
    const zoomYToSet = 1 / zoomYLength;
    const maxXZoom = getMaxXZoom(timelineElements.canvas.width, state);
    const maxYZoom = getMaxYZoom(timelineElements.canvas.height);
    const newXZoom = Math.min(maxXZoom, zoomXToSet);
    const newYZoom = Math.min(maxYZoom, zoomYToSet);
    state.left = left;
    state.right = right;
    state.zoomX = newXZoom;
    state.top = top;
    state.bottom = bottom;
    state.zoomY = newYZoom;

    timelineElements.overlayCanvas.dispatchEvent(
      new CustomEvent("range-change", {
        detail: {
          startZeroOne: state.left,
          endZeroOne: state.right,
          top: state.top,
          bottom: state.bottom,
          initialRender: initial,
          force: final,
        },
      })
    );
  };

  const updateZoom = (
    pXRatio,
    zoomAmount,
    state,
    sharedState,
    timelineElements
  ) => {
    const initialLeft = state.left;
    const initialRight = state.right;
    // Save prev zoom level
    const visiblePortionI = 1 / state.zoomX;
    const invisiblePortionI = 1 - visiblePortionI; // How much offscreen to distribute.
    // Update zoom level
    state.zoomX += Math.min(1, zoomAmount);
    state.zoomX = Math.max(1, state.zoomX);
    state.zoomX = Math.min(
      getMaxXZoom(timelineElements.canvas.width, state),
      state.zoomX
    );
    if (state.zoomX === 1) {
      state.left = 0;
      state.right = 1;
    } else {
      // See how much zoom level has changed, and how much we have to distribute.
      const visiblePortion = 1 / state.zoomX;
      const invisiblePortion = 1 - visiblePortion; // How much offscreen to distribute.
      // Distribute proportionally on either side of pX the increase in width/zoom.
      const newWToDistribute = invisiblePortion - invisiblePortionI;
      const leftShouldTake = newWToDistribute * pXRatio;
      const rightShouldTake = newWToDistribute * (1 - pXRatio);
      const prevLeft = state.left;
      const prevRight = state.right;

      state.left += leftShouldTake;
      state.left = Math.max(0, state.left);
      // NOTE: Balance out if one side took less than it's fair share.
      const leftTook = state.left - prevLeft;

      state.right -= newWToDistribute * (1 - pXRatio);
      state.right -= Math.min(0, leftShouldTake - leftTook);
      state.right = Math.min(1, state.right);

      // NOTE: If right didn't take everything it could, redistribute to the left.
      const rightTook = prevRight - state.right;
      state.left += Math.min(0, rightShouldTake - rightTook);
    }

    if (!sharedState.interacting) {
      const changeLeft = Math.abs(initialLeft - state.left);
      const changeRight = Math.abs(initialRight - state.right);
      if (changeLeft !== 0 || changeRight !== 0) {
        timelineElements.overlayCanvas.dispatchEvent(
          new Event("interaction-begin")
        );
        clearTimeout(sharedState.interactionTimeout);
        sharedState.interactionTimeout = setTimeout(() => {
          timelineElements.overlayCanvas.dispatchEvent(
            new Event("interaction-end")
          );
        }, 300);
      }
    }

    timelineElements.overlayCanvas.dispatchEvent(
      new CustomEvent("range-change", {
        detail: {
          startZeroOne: state.left,
          endZeroOne: state.right,
          initialRender: false,
        },
      })
    );
  };

  const updatePinch = (
    xStartPxRatio,
    xEndPxRatio,
    initialXStartPxRatio,
    initialXEndPxRatio,
    state,
    canvas
  ) => {
    // Range between two points.  This should remain constant
    const initialRatio = initialXEndPxRatio - initialXStartPxRatio;
    const newRatio = xEndPxRatio - xStartPxRatio;
    const maxZoomX = getMaxXZoom(canvas.width, state);
    const zoomX = Math.min(newRatio / initialRatio, maxZoomX);
    const visiblePortionI = 1 / zoomX;
    let initialLeft = initialXStartPxRatio - xStartPxRatio / zoomX;
    let initialRight = initialLeft + visiblePortionI;
    const range = initialXEndPxRatio - initialXStartPxRatio;

    const maxOutOfBounds = range * 0.25;
    // If left or right is outside the 0..1 bounds, start to add resistance, proportional to how much over it is.
    if (initialLeft < 0) {
      const a = Math.max(-maxOutOfBounds, initialLeft);
      const b = Math.abs(a) / 2;
      const c = Math.sqrt(b) / 3;
      initialLeft = c * a;
      initialRight = initialLeft + visiblePortionI;
    } else if (initialRight > 1) {
      if (state.panStarted) {
        initialLeft = 1 - state.initialPanRange;
      } else if (state.pinchStarted) {
        initialLeft = initialRight - visiblePortionI;
      }
    }
    state.left = Math.max(0, initialLeft);
    state.right = Math.min(1, initialRight);
    canvas.dispatchEvent(
      new CustomEvent("range-change", {
        detail: {
          startZeroOne: state.left,
          endZeroOne: state.right,
          initialRender: false,
        },
      })
    );
  };

  const onPointerMove = (canvas, state, sharedState) => {
    const numPointers = Object.keys(state.pointers).length;
    if (numPointers <= 2) {
      const pointers = Object.values(state.pointers);
      const canvasWidth = canvas.width / devicePixelRatio;

      let pinchXLeftZeroOne;
      let pinchXRightZeroOne;
      if (numPointers === 2) {
        if (!state.panStarted || state.pinchStarted) {
          const x0 = pointers[0].x;
          const x1 = pointers[1].x;
          pinchXLeftZeroOne = Math.max(0, Math.min(x0, x1) / canvasWidth);
          pinchXRightZeroOne = Math.min(1, Math.max(x0, x1) / canvasWidth);
          if (!state.pinchStarted) {
            state.pinchStarted = true;
            if (!sharedState.interacting) {
              canvas.dispatchEvent(new Event("interaction-begin"));
            }
            const range = state.right - state.left;
            state.initialPinchXLeftZeroOne =
              state.left + range * pinchXLeftZeroOne;
            state.initialPinchXRightZeroOne =
              state.left + range * pinchXRightZeroOne;
          }
        } else {
          state.pinchStarted = false;
          state.panStarted = false;
        }
      } else if (numPointers === 1) {
        const scrubLocal = state.scrubLocalStarted;
        const scrubGlobal = state.scrubGlobalStarted;
        const isScrubbing = scrubGlobal || scrubLocal;
        if (!state.pinchStarted) {
          let range = state.right - state.left;
          if (state.panStarted) {
            range = state.initialPanRange;
          }
          const x0 = pointers[0].x / canvasWidth;
          pinchXLeftZeroOne = Math.max(0, x0);
          pinchXRightZeroOne = pinchXLeftZeroOne + range;
          if (
            !state.pinchStarted &&
            !state.panStarted &&
            !state.scrubGlobalStarted &&
            !state.scrubLocalStarted
          ) {
            state.panStarted = true;
            if (!sharedState.interacting) {
              canvas.dispatchEvent(new Event("interaction-begin"));
            }
            state.initialPinchXLeftZeroOne = Math.max(
              0,
              state.left + range * pinchXLeftZeroOne
            );
            state.initialPinchXRightZeroOne = Math.min(
              1,
              state.left + range * pinchXRightZeroOne
            );
            state.startPanXZeroOne = state.left;
            state.initialPanRange = state.right - state.left;
          } else if (isScrubbing) {
            if (!sharedState.interacting) {
              canvas.dispatchEvent(new Event("interaction-begin"));
            }
            const progress =
              (pointers[0].x - state.scrubDragOffsetX) / canvasWidth;
            if (scrubLocal) {
              state.dragLocalPlayhead(progress);
            } else if (scrubGlobal) {
              state.dragGlobalPlayhead(progress);
            }
          } else if (state.panStarted) {
            const localLeft = Math.max(
              0,
              state.startPanXZeroOne + range * pinchXLeftZeroOne
            );
            state.left = Math.min(
              1 - state.initialPanRange,
              Math.max(
                0,
                state.startPanXZeroOne -
                (localLeft - state.initialPinchXLeftZeroOne)
              )
            );
            state.right = state.left + state.initialPanRange;
            canvas.dispatchEvent(
              new CustomEvent("range-change", {
                detail: {
                  startZeroOne: state.left,
                  endZeroOne: state.right,
                  initialRender: false,
                },
              })
            );
          }
        } else {
          state.pinchStarted = false;
          state.panStarted = false;
        }
      }
      if (
        (sharedState.interacting && state.pinchStarted && numPointers < 2) ||
        (state.panStarted && numPointers < 1)
      ) {
        canvas.dispatchEvent(new Event("interaction-end"));
      }
      // TODO: We may want to allow pinching in to less than 100%, and then bounce back out.
      if (state.pinchStarted) {
        updatePinch(
          pinchXLeftZeroOne,
          pinchXRightZeroOne,
          state.initialPinchXLeftZeroOne,
          state.initialPinchXRightZeroOne,
          state,
          canvas
        );
      }
    }
  };

  const startHandleDrag = (e, timelineElements, timelineState, xOffset) => {
    if (e.isPrimary && !timelineState.currentAction) {
      const handle = timelineElements.timelineUICanvas;
      handle.setPointerCapture(e.pointerId);
      timelineState.currentAction = "pan";
      if (e.pressure > 0 && e.pointerType !== "touch") {
        if (!handle.classList.contains("grabbing")) {
          handle.classList.add("grabbing");
        }
      }
      timelineState.handleStartOffsetXZeroOne = timelineState.left;
      timelineState.handleDragOffsetX = xOffset;
      timelineElements.overlayCanvas.dispatchEvent(
        new Event("interaction-begin")
      );
    }
  };

  const endHandleDrag = (e, timelineElements, state) => {
    if (e.isPrimary) {
      timelineElements.timelineUICanvas.releasePointerCapture(e.pointerId);
      if (e.pointerType !== "touch") {
        if (timelineElements.timelineUICanvas.classList.contains("grabbing")) {
          timelineElements.timelineUICanvas.classList.remove("grabbing", "grab");
        }
      }
      state.currentAction = null;
      timelineElements.overlayCanvas.dispatchEvent(new Event("interaction-end"));
    }
  };

  const dragHandle = (e, timelineElements, state, thisOffsetX) => {
    if (
      e.isPrimary &&
      e.target.hasPointerCapture(e.pointerId) &&
      state.currentAction === "pan"
    ) {
      const xOffset = state.handleDragOffsetX - state.handleStartOffsetXZeroOne;
      const range = state.right - state.left;
      let initialLeft = state.left;
      let initialRight = state.right;
      state.left = thisOffsetX - xOffset;
      state.right = state.left + range;
      if (state.left < 0 || state.right > 1) {
        if (state.right > 1 && state.left > 0) {
          state.right = 1;
          state.left = state.right - range;
        } else if (state.left < 0 && state.right < 1) {
          state.left = 0;
          state.right = state.left + range;
        } else {
          state.left = initialLeft;
          state.right = initialRight;
        }
      }
      timelineElements.overlayCanvas.dispatchEvent(
        new CustomEvent("range-change", {
          detail: {
            startZeroOne: state.left,
            endZeroOne: state.right,
            initialRender: false,
          },
        })
      );
    } else {
      e.preventDefault();
    }
  };

  const drawTimelineUI =
    (timelineElements, state) => (startZeroOne, endZeroOne, currentAction) => {
      // Draw handles on timelineUICanvas.
      const isDarkTheme = state.isDarkTheme;
      const ctx = timelineElements.timelineUICanvas.getContext("2d");
      const width = ctx.canvas.width;
      const height = ctx.canvas.height;
      const start = startZeroOne * width;
      const end = endZeroOne * width;
      const onePx = devicePixelRatio;
      const halfPx = 0.5 * devicePixelRatio;
      const twoPx = 2 * devicePixelRatio;
      const threePx = 3 * devicePixelRatio;
      const handleWidth = end - start - onePx;
      const minHandleWidth = 44 * devicePixelRatio;
      const handleIsNarrow = handleWidth < minHandleWidth;
      const unselectedHandleColor = isDarkTheme ? "#b1b2b5" : "#595959";
      const selectedHandleColor = isDarkTheme ? "#cccdd1" : "#333333";
      const resizeHandleAt = (x, color, cX) => {
        const y = height / 2 - handleHeight / 2;
        const halfWidth = resizeHandleWidth / 2;
        ctx.fillStyle = color;
        ctx.beginPath();
        const atStart = x < halfWidth;

        const atEnd = x + resizeHandleWidth > width - halfWidth;
        if (atStart || atEnd) {
          if (atStart) {
            ctx.roundRect(x, y, resizeHandleWidth, handleHeight, [
              cX,
              halfWidth,
              halfWidth,
              cX,
            ]);
          } else {
            ctx.roundRect(x, y, resizeHandleWidth, handleHeight, [
              halfWidth,
              cX,
              cX,
              halfWidth,
            ]);
          }
          ctx.roundRect(x, y, resizeHandleWidth, handleHeight, halfWidth);
        } else {
          ctx.roundRect(x, y, resizeHandleWidth, handleHeight, halfWidth);
        }
        ctx.fill();
        ctx.fillStyle = isDarkTheme ? "#666" : "#ccc";
        ctx.beginPath();
        const circleX = x + halfWidth - 1.5 * devicePixelRatio;
        const circleC = 3 * devicePixelRatio;
        ctx.roundRect(
          circleX,
          y + 4.5 * devicePixelRatio,
          circleC,
          circleC,
          circleC * 0.5
        );
        ctx.roundRect(
          circleX,
          y + 10.5 * devicePixelRatio,
          circleC,
          circleC,
          circleC * 0.5
        );
        ctx.roundRect(
          circleX,
          y + 16.5 * devicePixelRatio,
          circleC,
          circleC,
          circleC * 0.5
        );
        ctx.fill();
      };

      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle =
        currentAction !== null ? `rgba(0, 0, 0, 0.25)` : "rgba(0, 0, 0, 0.2)";
      ctx.beginPath();
      ctx.rect(0, 0, width, height);

      const vStep1 = height / 2;
      const vStep2 = (height / 4) * 3;

      const drawPanHandlePath = (handleIsNarrow, selected) => {
        if (!handleIsNarrow) {
          if (!selected) {
            ctx.roundRect(
              Math.max(halfPx, start),
              halfPx,
              handleWidth,
              height - onePx,
              threePx
            );
          } else {
            ctx.roundRect(
              start + onePx,
              onePx,
              handleWidth - onePx,
              height - twoPx,
              threePx
            );
          }
        } else {
          // Something fancy, a kind of funnel from the wide grabby bit of the handle to the width that shows how wide
          // the current selection range actually is.
          const left = Math.max(halfPx, start);
          const leftWideExtreme = Math.min(
            width - minHandleWidth - halfPx,
            Math.max(halfPx, left - minHandleWidth / 2 + handleWidth / 2)
          );
          const rightWideExtreme = leftWideExtreme + minHandleWidth; //(minHandleWidth / 2) - (handleWidth / 2);
          const top = halfPx;
          const bottom = height - onePx;

          ctx.moveTo(left, top);
          ctx.lineTo(left + handleWidth - threePx, halfPx);
          ctx.arcTo(
            left + handleWidth,
            halfPx,
            left + handleWidth,
            halfPx + threePx,
            threePx
          );
          ctx.bezierCurveTo(
            left + handleWidth,
            vStep2,
            rightWideExtreme,
            vStep1,
            rightWideExtreme,
            bottom - threePx
          );
          ctx.arcTo(
            rightWideExtreme,
            bottom,
            rightWideExtreme - threePx,
            bottom,
            threePx
          );
          ctx.lineTo(leftWideExtreme + threePx, bottom);
          ctx.arcTo(
            leftWideExtreme,
            bottom,
            leftWideExtreme,
            bottom - threePx,
            threePx
          );
          ctx.bezierCurveTo(
            leftWideExtreme,
            vStep1,
            left,
            vStep2,
            left,
            top + threePx
          );
          ctx.arcTo(left, top, left + threePx, top, threePx);
        }
      };

      // Draw track and pan handle cutout
      drawPanHandlePath(handleIsNarrow, false);
      ctx.fill("evenodd");

      // Stroke pan handle
      ctx.beginPath();
      if (currentAction === "pan") {
        ctx.strokeStyle = selectedHandleColor; //`rgba(${c}, ${c}, ${c}, 1)`;
        ctx.lineWidth = twoPx;
        drawPanHandlePath(handleIsNarrow, true);
      } else {
        ctx.strokeStyle = unselectedHandleColor; //`rgba(${c}, ${c}, ${c}, 0.75)`;
        ctx.lineWidth = onePx;
        drawPanHandlePath(handleIsNarrow, false);
      }
      ctx.stroke();

      // Draw resize handles
      const resizeHandleWidth = 8 * devicePixelRatio;
      const handleHeight = 24 * devicePixelRatio;
      const leftHandleColour =
        currentAction === "resize-left" || state.overLeftHandle
          ? selectedHandleColor
          : unselectedHandleColor;
      const rightHandleColour =
        currentAction === "resize-right" || state.overRightHandle
          ? selectedHandleColor
          : unselectedHandleColor;
      const halfWidth = resizeHandleWidth / 2;
      let leftX;
      const leftC = Math.min(
        halfWidth,
        halfWidth - Math.min(halfWidth, halfWidth - start)
      );
      let rightC = Math.min(
        halfWidth,
        halfWidth - Math.min(halfWidth, halfWidth - (width - end))
      );
      if (handleWidth > minHandleWidth * 2) {
        leftX = Math.max(0, start - resizeHandleWidth * 0.5);
      } else {
        leftX =
          Math.max(0, start - resizeHandleWidth * 0.5) +
          (handleWidth / 2 - minHandleWidth);
      }
      let rightX;
      if (handleWidth > minHandleWidth * 2) {
        rightX =
          Math.min(width - resizeHandleWidth, end - resizeHandleWidth * 0.5) -
          onePx;
      } else {
        rightX = Math.min(
          width - resizeHandleWidth,
          end - resizeHandleWidth * 0.5 - (handleWidth / 2 - minHandleWidth)
        );
      }
      // Draw left resize handle
      resizeHandleAt(leftX, leftHandleColour, leftC);
      // Draw right resize handle
      resizeHandleAt(rightX, rightHandleColour, rightC);
    };

  const startHandleResize = (e, timelineElements, state, xOffset, action) => {
    if (e.isPrimary && !state.currentAction) {
      const target = e.target;
      target.setPointerCapture(e.pointerId);
      state.currentAction = action;
      if (action === "resize-left") {
        state.handleStartOffsetXZeroOne = state.left;
      } else if (action === "resize-right") {
        state.handleStartOffsetXZeroOne = state.right;
      }
      state.handleDragOffsetX = xOffset;
      timelineElements.overlayCanvas.dispatchEvent(
        new Event("interaction-begin")
      );
    }
  };
  const endHandleResize = (e, timelineElements, state) => {
    if (e.isPrimary) {
      const target = e.target;
      if (
        state.currentAction === "resize-left" ||
        state.currentAction === "resize-right"
      ) {
        target.releasePointerCapture(e.pointerId);
        state.currentAction = null;
        timelineElements.overlayCanvas.dispatchEvent(
          new Event("interaction-end")
        );
      }
    }
  };
  const dragResize = (e, timelineElements, state, xOffsetZeroOne) => {
    if (e.isPrimary && e.target.hasPointerCapture(e.pointerId)) {
      const thisOffsetX =
        xOffsetZeroOne -
        (state.handleDragOffsetX - state.handleStartOffsetXZeroOne);
      const minRange = 1 / getMaxXZoom(timelineElements.canvas.width, state);
      if (state.currentAction === "resize-left") {
        state.left = Math.max(0, Math.min(state.right, thisOffsetX));
        if (state.right - state.left < minRange) {
          state.left = state.right - minRange;
        }
      } else if (state.currentAction === "resize-right") {
        state.right = Math.min(1, Math.max(state.left, thisOffsetX));
        if (state.right - state.left < minRange) {
          state.right = state.left + minRange;
        }
      }
      state.zoomX = 1 / (state.right - state.left);
      timelineElements.overlayCanvas.dispatchEvent(
        new CustomEvent("range-change", {
          detail: {
            startZeroOne: state.left,
            endZeroOne: state.right,
            initialRender: false,
          },
        })
      );
    }
  };

  const initTimeline = (root, sharedState, timelineElements) => {
    const state = {
      currentAction: null,
      handleStartOffsetXZeroOne: undefined,
      handleDragOffsetX: undefined,
      pinchRaf: undefined,
      left: 0,
      right: 1,
      top: 1,
      bottom: 0,
      pinchStarted: false,
      panStarted: false,
      initialPinchXLeftZeroOne: 0,
      initialPinchXRightZeroOne: 1,
      zoomX: 1,
      isDarkTheme: true,
      numAudioSamples: 0,
      drawTimelineUI,
      pointers: {},
      customInteractionMode: false,
      scrubGlobalStarted: false,
      scrubLocalStarted: false,
      overLeftHandle: false,
      overRightHandle: false,
      overPanHandle: false,
      overSeekTrack: false,
    };

    state.drawTimelineUI = drawTimelineUI(timelineElements, state);

    const hitTestTimeline = (xOffsetZeroOne) => {
      //console.log("hitTestTimeline", xOffsetZeroOne);
      const resizeHandleWidthCssPx = 44;
      const handleWidthZeroOne =
        resizeHandleWidthCssPx /
        (timelineElements.canvas.width / devicePixelRatio);

      let leftResizeLeft = Math.max(0, state.left - handleWidthZeroOne * 0.5);
      let leftResizeRight = leftResizeLeft + handleWidthZeroOne;
      let rightResizeRight = Math.min(1, state.right + handleWidthZeroOne * 0.5);
      let rightResizeLeft = rightResizeRight - handleWidthZeroOne;

      // TODO: Correctly handle if the pan handle is very narrow at either extreme of the timeline.
      const panHandleWidth = rightResizeLeft - leftResizeRight;
      if (panHandleWidth < handleWidthZeroOne) {
        leftResizeLeft = Math.max(
          0,
          state.left -
          handleWidthZeroOne * 0.5 -
          (handleWidthZeroOne - panHandleWidth) * 0.5
        );
        rightResizeRight = Math.min(
          1,
          state.right +
          handleWidthZeroOne * 0.5 +
          (handleWidthZeroOne - panHandleWidth) * 0.5
        );
      }
      rightResizeLeft = rightResizeRight - handleWidthZeroOne;
      if (leftResizeLeft === 0 && rightResizeLeft < handleWidthZeroOne) {
        leftResizeLeft = -handleWidthZeroOne;
      }
      leftResizeRight = leftResizeLeft + handleWidthZeroOne;
      rightResizeLeft = rightResizeRight - handleWidthZeroOne;

      // const ctx = timelineElements.timelineUICanvas.getContext("2d");
      // ctx.save();
      // ctx.strokeStyle = 'red';
      // console.log("leftResizeLeft", leftResizeLeft);
      // console.log("rightResizeLeft", rightResizeLeft);
      // ctx.strokeRect(leftResizeLeft * ctx.canvas.width, 0, (leftResizeRight - leftResizeLeft) * ctx.canvas.width, ctx.canvas.height);
      // ctx.strokeRect(rightResizeLeft * ctx.canvas.width, 0, (rightResizeRight - rightResizeLeft) * ctx.canvas.width, ctx.canvas.height);
      // ctx.restore();

      const inResizeHandleLeft =
        xOffsetZeroOne >= leftResizeLeft && xOffsetZeroOne <= leftResizeRight;
      const inResizeHandleRight =
        xOffsetZeroOne >= rightResizeLeft && xOffsetZeroOne <= rightResizeRight;
      const inMainPanHandle =
        xOffsetZeroOne >= leftResizeLeft && xOffsetZeroOne <= rightResizeRight;
      const inSeekTrack = !inMainPanHandle;
      const targetChanged =
        state.overLeftHandle !== inResizeHandleLeft ||
        state.overRightHandle !== inResizeHandleRight ||
        state.overPanHandle !== inMainPanHandle ||
        state.overSeekTrack !== inSeekTrack;
      state.overLeftHandle = inResizeHandleLeft;
      state.overRightHandle = inResizeHandleRight;
      state.overPanHandle = inMainPanHandle;
      state.overSeekTrack = inSeekTrack;
      return {
        inResizeHandleLeft,
        inResizeHandleRight,
        inSeekTrack,
        targetChanged,
      };
    };

    timelineElements.timelineUICanvas.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopImmediatePropagation();
      if (e.pointerType === "mouse" && e.button !== 0) {
        // Only response to left mouse clicks
        return;
      }
      const xOffsetZeroOne =
        e.offsetX / (timelineElements.canvas.width / devicePixelRatio);
      const {
        inResizeHandleLeft,
        inResizeHandleRight,
        inSeekTrack,
        targetChanged,
      } = hitTestTimeline(xOffsetZeroOne);

      let redrawnUI = false;
      if (inSeekTrack) {
        // Clicking outside handle.
        if (!state.currentAction) {
          clickOutsideHandle(state, timelineElements, xOffsetZeroOne);
          redrawnUI = true;
        }
      } else {
        if (inResizeHandleLeft) {
          startHandleResize(
            e,
            timelineElements,
            state,
            xOffsetZeroOne,
            "resize-left"
          );
        } else if (inResizeHandleRight) {
          startHandleResize(
            e,
            timelineElements,
            state,
            xOffsetZeroOne,
            "resize-right"
          );
        } else {
          startHandleDrag(e, timelineElements, state, xOffsetZeroOne);
        }
        redrawnUI = true;
      }
      if (targetChanged && !redrawnUI) {
        // Redraw UI for i.e. hover events
        timelineElements.overlayCanvas.dispatchEvent(
          new Event("interaction-target-changed")
        );
      }
    });
    timelineElements.timelineUICanvas.addEventListener("pointerup", (e) => {
      e.preventDefault();
      e.stopImmediatePropagation();
      if (state.currentAction !== null) {
        switch (state.currentAction) {
          case "pan":
            endHandleDrag(e, timelineElements, state);
            break;
          case "resize-left":
          case "resize-right":
            endHandleResize(e, timelineElements, state);
            break;
        }
      }
    });
    timelineElements.timelineUICanvas.addEventListener("pointerleave", () => {
      state.overSeekTrack = false;
      state.overLeftHandle = false;
      state.overRightHandle = false;
      state.overPanHandle = false;
      timelineElements.overlayCanvas.dispatchEvent(
        new Event("interaction-target-changed")
      );
    });
    timelineElements.timelineUICanvas.addEventListener("pointermove", (e) => {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      const xOffsetZeroOne =
        e.offsetX / (timelineElements.timelineUICanvas.width / devicePixelRatio);
      if (state.currentAction !== null) {
        switch (state.currentAction) {
          case "pan":
            dragHandle(e, timelineElements, state, xOffsetZeroOne);
            break;
          case "resize-left":
          case "resize-right":
            dragResize(e, timelineElements, state, xOffsetZeroOne);
            break;
        }
      } else if (e.pressure === 0 && e.pointerType === "mouse") {
        const {
          inResizeHandleLeft,
          inResizeHandleRight,
          inSeekTrack,
          targetChanged,
        } = hitTestTimeline(xOffsetZeroOne);

        // Add classes to DOM for cursors?
        if (inResizeHandleLeft || inResizeHandleRight) {
          if (!timelineElements.timelineUICanvas.classList.contains("resize")) {
            timelineElements.timelineUICanvas.classList.add("resize");
          }
        } else if (!inSeekTrack) {
          if (timelineElements.timelineUICanvas.classList.contains("resize")) {
            timelineElements.timelineUICanvas.classList.remove("resize");
          }
          timelineElements.timelineUICanvas.classList.add("grab");
        } else {
          if (
            timelineElements.timelineUICanvas.classList.contains("grab") ||
            timelineElements.timelineUICanvas.classList.contains("resize") ||
            timelineElements.timelineUICanvas.classList.contains("grabbing")
          ) {
            timelineElements.timelineUICanvas.classList.remove(
              "grab",
              "resize",
              "grabbing"
            );
          }
        }
        if (targetChanged) {
          // Redraw UI for i.e. hover events
          timelineElements.overlayCanvas.dispatchEvent(
            new Event("interaction-target-changed")
          );
        }
      }
    });

    const hitTestScrubHandles = (x, y) => {
      const numPointers = Object.keys(state.pointers).length;
      const atBottom = y > timelineElements.canvas.height / devicePixelRatio - 44;
      const atTop = y < 44;
      let inLocalPlaybackScrubberHandle = false;
      let inGlobalPlaybackScrubberHandle = false;
      if (numPointers < 2 && (atTop || atBottom)) {
        const audioProgressZeroOne = state.audioState.audioProgressZeroOne;
        const minHandleWidth = 44;
        const width =
          timelineElements.mainPlayheadCanvas.width / devicePixelRatio;
        if (
          atTop &&
          audioProgressZeroOne >= state.left &&
          audioProgressZeroOne <= state.right
        ) {
          const localProgress =
            (audioProgressZeroOne - state.left) / (state.right - state.left);
          const localPlaybackLeft = Math.max(
            0,
            localProgress * width - minHandleWidth / 2
          );
          const localPlaybackRight = localPlaybackLeft + minHandleWidth;
          if (x >= localPlaybackLeft && x <= localPlaybackRight) {
            inLocalPlaybackScrubberHandle = true;
          }
        } else if (atBottom) {
          const globalPlaybackLeft = Math.max(
            0,
            audioProgressZeroOne * width - minHandleWidth / 2
          );
          const globalPlaybackRight = globalPlaybackLeft + minHandleWidth;
          if (x >= globalPlaybackLeft && x <= globalPlaybackRight) {
            inGlobalPlaybackScrubberHandle = true;
          }
        }
      }
      const targetChanged =
        state.inLocalPlaybackScrubberHandle !== inLocalPlaybackScrubberHandle ||
        state.inGlobalPlaybackScrubberHandle !== inGlobalPlaybackScrubberHandle;
      state.inLocalPlaybackScrubberHandle = inLocalPlaybackScrubberHandle;
      state.inGlobalPlaybackScrubberHandle = inGlobalPlaybackScrubberHandle;

      return {
        inLocalPlaybackScrubberHandle,
        inGlobalPlaybackScrubberHandle,
        targetChanged,
      };
    };

    timelineElements.timelineUICanvas.addEventListener("pointercancel", (e) => {
      e.preventDefault();
      e.stopImmediatePropagation();
      if (state.currentAction !== null) {
        switch (state.currentAction) {
          case "pan":
            endHandleDrag(e, timelineElements, state);
            break;
          case "resize-left":
          case "resize-right":
            endHandleResize(e, timelineElements, state);
            break;
        }
      }
    });
    timelineElements.overlayCanvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const xOffset =
        e.offsetX / (timelineElements.canvas.width / devicePixelRatio);
      const dY = e.deltaY;
      let amount;
      if (Math.floor(dY) === dY) {
        // This is a mousewheel event (with integer values).
        amount = -e.deltaY * 0.001;
      } else {
        // This is likely a trackpad pinch event (with real number values)
        amount = -e.deltaY * 0.01;
      }
      updateZoom(xOffset, amount, state, sharedState, timelineElements);
    });
    timelineElements.timelineUICanvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const xOffset =
        e.offsetX / (timelineElements.canvas.width / devicePixelRatio);
      const dY = e.deltaY;
      let amount;
      if (Math.floor(dY) === dY) {
        // This is a mousewheel event (with integer values).
        amount = -e.deltaY * 0.001;
      } else {
        // This is likely a trackpad pinch event (with real number values)
        amount = -e.deltaY * 0.01;
      }
      const inHandle = xOffset >= state.left && xOffset <= state.right;
      if (inHandle) {
        updateZoom(xOffset, amount, state, sharedState, timelineElements);
      }
    });
    timelineElements.overlayCanvas.addEventListener("pointerdown", (e) => {
      if (
        e.pointerType === "touch" ||
        (e.pointerType === "mouse" && e.button !== -1) ||
        e.pressure > 0
      ) {
        e.preventDefault();
        let numPointers = Object.keys(state.pointers).length;
        if (numPointers < 2) {
          state.pointers[e.pointerId] = {
            x: e.offsetX,
            y: e.offsetY,
            time: performance.now(),
          };
          timelineElements.overlayCanvas.setPointerCapture(e.pointerId);
        }
        const {inLocalPlaybackScrubberHandle, inGlobalPlaybackScrubberHandle} =
          hitTestScrubHandles(e.offsetX, e.offsetY);
        state.interactionStartX = e.offsetX;
        state.interactionStartY = e.offsetY;
        const width =
          timelineElements.mainPlayheadCanvas.width / devicePixelRatio;
        if (state.customInteractionMode) {
          root.dispatchEvent(
            new CustomEvent("custom-interaction-start", {
              bubbles: false,
              composed: true,
              cancelable: false,
              detail: {
                offsetX: e.offsetX,
                offsetY: e.offsetY,
                container: timelineElements.overlayCanvas,
              },
            })
          );
        }
        if (state.customInteractionMode && state.inCustomInteraction) ; else {
          if (inGlobalPlaybackScrubberHandle) {
            // Drag global playtime scrubber
            state.scrubGlobalStarted = true;

            state.scrubDragOffsetX =
              e.offsetX - state.audioState.audioProgressZeroOne * width;
            state.startPlayheadDrag();
            if (e.pointerType === "mouse") {
              if (
                !timelineElements.spectrogramContainer.classList.contains(
                  "dragging"
                )
              ) {
                timelineElements.spectrogramContainer.classList.add("dragging");
              }
            }
          } else if (inLocalPlaybackScrubberHandle) {
            // Drag local playtime scrubber
            state.scrubLocalStarted = true;
            const localProgress =
              (state.audioState.audioProgressZeroOne - state.left) /
              (state.right - state.left);
            state.scrubDragOffsetX = e.offsetX - localProgress * width;
            state.startPlayheadDrag();
            if (e.pointerType === "mouse") {
              if (
                !timelineElements.spectrogramContainer.classList.contains(
                  "dragging"
                )
              ) {
                timelineElements.spectrogramContainer.classList.add("dragging");
              }
            }
          }
        }
      }
    });
    timelineElements.overlayCanvas.addEventListener("pointerleave", () => {
      state.inGlobalPlaybackScrubberHandle = false;
      state.inLocalPlaybackScrubberHandle = false;
      timelineElements.overlayCanvas.dispatchEvent(
        new Event("interaction-target-changed")
      );
    });

    timelineElements.overlayCanvas.addEventListener("pointermove", (e) => {
      e.preventDefault();
      e.stopImmediatePropagation();
      if (
        e.pointerType === "touch" ||
        (e.pointerType === "mouse" && e.button !== -1) ||
        e.pressure > 0
      ) {
        state.pointers[e.pointerId] = {
          x: e.offsetX,
          y: e.offsetY,
          time: performance.now(),
        };
        if (state.customInteractionMode && state.inCustomInteraction) {
          // Do nothing.
          root.dispatchEvent(
            new CustomEvent("custom-interaction-move", {
              bubbles: false,
              composed: true,
              cancelable: false,
              detail: {
                offsetX: e.offsetX,
                offsetY: e.offsetY,
                container: timelineElements.overlayCanvas,
              },
            })
          );
        } else {
          onPointerMove(timelineElements.overlayCanvas, state, sharedState);
          if (state.panStarted && e.pointerType === "mouse") {
            if (
              !timelineElements.spectrogramContainer.classList.contains(
                "dragging"
              )
            ) {
              timelineElements.spectrogramContainer.classList.add("dragging");
            }
          }
        }
      } else if (e.pointerType === "mouse" && e.pressure === 0) {
        const {targetChanged} = hitTestScrubHandles(e.offsetX, e.offsetY);
        if (targetChanged) {
          timelineElements.overlayCanvas.dispatchEvent(
            new Event("interaction-target-changed")
          );
        }
        // NOTE: Re-dispatch mousemove for user/client embed handling.
        root.dispatchEvent(
          new CustomEvent("move", {
            bubbles: false,
            composed: true,
            cancelable: false,
            detail: {
              offsetX: e.offsetX,
              offsetY: e.offsetY,
              container: timelineElements.spectrogramContainer,
            },
          })
        );
      }
    });

    const distanceBetweenPoints = (x1, y1, x2, y2) => {
      const dX = Math.abs(x1 - x2);
      const dY = Math.abs(y1 - y2);
      return Math.sqrt(dX * dX + dY * dY);
    };
    const clampZeroOne = (x) => Math.max(0, Math.min(1, x));

    const endPointerInteraction = (e) => {
      e.preventDefault();
      e.stopImmediatePropagation();
      const maxDoubleClickIntervalMs = 200;
      timelineElements.overlayCanvas.releasePointerCapture(e.pointerId);
      let doubleClickEventEmitted = false;

      let wasInCustomInteraction =
        state.customInteractionMode && state.inCustomInteraction;
      if (state.customInteractionMode && state.inCustomInteraction) {
        root.dispatchEvent(
          new CustomEvent("custom-interaction-end", {
            composed: true,
            bubbles: false,
            cancelable: false,
            detail: {
              offsetX: e.offsetX,
              offsetY: e.offsetY,
              container: timelineElements.overlayCanvas,
            },
          })
        );
      } else {
        // Check if we're in a double click
        if (
          state.pointers[e.pointerId] &&
          Object.keys(state.pointers).length === 1
        ) {
          const timeElapsed =
            performance.now() - state.pointers[e.pointerId].time;
          const distanceMoved = distanceBetweenPoints(
            state.pointers[e.pointerId].x,
            state.pointers[e.pointerId].y,
            e.offsetX,
            e.offsetY
          );
          // NOTE: This need to be a double-click, because a single click action would clash with the select action
          //  We need to delay the select action my `maxDoubleClickInterval` to make sure
          //  it wasn't the beginning of a double-click action.
          if (distanceMoved < 4 * devicePixelRatio && timeElapsed < 200) {
            clearTimeout(state.selectPending);
            if (state.doubleClickInProgress) {
              const timeElapsed =
                performance.now() - state.doubleClickInProgress.time;
              const distanceMoved = distanceBetweenPoints(
                state.doubleClickInProgress.x,
                state.doubleClickInProgress.y,
                e.offsetX,
                e.offsetY
              );
              if (
                distanceMoved < 4 * devicePixelRatio &&
                timeElapsed < maxDoubleClickIntervalMs
              ) {
                const offsetZeroOne =
                  e.offsetX / (timelineElements.canvas.width / devicePixelRatio);
                const c = clampZeroOne(offsetZeroOne);
                const audioOffsetZeroOne =
                  state.left + c * (state.right - state.left);
                doubleClickEventEmitted = true;
                timelineElements.overlayCanvas.dispatchEvent(
                  new CustomEvent("double-click", {
                    detail: {
                      audioOffsetZeroOne,
                    },
                  })
                );
              }
            }
            state.doubleClickInProgress = {
              x: e.offsetX,
              y: e.offsetY,
              time: performance.now(),
            };
          }
        }
      }
      delete state.pointers[e.pointerId];
      const numPointers = Object.keys(state.pointers).length;
      if (!wasInCustomInteraction) {
        if (numPointers < 2) {
          if (sharedState.interacting && state.pinchStarted) {
            timelineElements.overlayCanvas.dispatchEvent(
              new Event("interaction-end")
            );
          }
          state.pinchStarted = false;
        }
        if (numPointers < 1) {
          if (state.scrubLocalStarted || state.scrubGlobalStarted) {
            state.endPlayheadDrag();
          }

          const pointerMoved = () => {
            const dX = Math.abs(state.interactionStartX - e.offsetX);
            const dY = Math.abs(state.interactionStartY - e.offsetY);
            return dX > 4 || dY > 4;
          };
          const movedEnough = pointerMoved();
          if (
            !movedEnough ||
            (!state.scrubLocalStarted &&
              !state.scrubGlobalStarted &&
              !state.pinchStarted &&
              (!state.panStarted || (state.panStarted && !movedEnough)))
          ) {
            // Clicked without moving pointer
            if (!doubleClickEventEmitted) {
              const x = e.offsetX;
              const y = e.offsetY;
              state.selectPending = setTimeout(() => {
                root.dispatchEvent(
                  new CustomEvent("select", {
                    bubbles: false,
                    composed: true,
                    cancelable: false,
                    detail: {
                      offsetX: x,
                      offsetY: y,
                      container: timelineElements.spectrogramContainer,
                    },
                  })
                );
              }, maxDoubleClickIntervalMs);
            }
          }
          if (
            timelineElements.spectrogramContainer.classList.contains("dragging")
          ) {
            timelineElements.spectrogramContainer.classList.remove("dragging");
          }

          state.panStarted = false;
          state.scrubGlobalStarted = false;
          state.scrubLocalStarted = false;
          state.pinchStarted = false;
        }
      }
      if (numPointers < 1 && sharedState.interacting) {
        timelineElements.overlayCanvas.dispatchEvent(
          new Event("interaction-end")
        );
      }
    };

    timelineElements.overlayCanvas.addEventListener(
      "pointerup",
      endPointerInteraction
    );
    timelineElements.overlayCanvas.addEventListener(
      "pointercancel",
      endPointerInteraction
    );

    const curriedSetInitialZoom = (left, right, top, bottom, initial, final) =>
      setInitialZoom(
        left,
        right,
        top,
        bottom,
        state,
        sharedState,
        timelineElements,
        initial,
        final
      );
    return {
      drawTimelineUI: drawTimelineUI(timelineElements, state),
      timelineState: state,
      animateToRange,
      getMaxXZoom: () => getMaxXZoom(timelineElements.canvas.width, state),
      getMaxYZoom: () => getMaxYZoom(timelineElements.canvas.height),
      resetYZoom: () =>
        animateToRange(
          state.left,
          state.right,
          state.top,
          state.bottom,
          state.left,
          state.right,
          1,
          0,
          100,
          (left, right, top, bottom, final) =>
            curriedSetInitialZoom(left, right, top, bottom, false, final)
        ),
      setInitialZoom: curriedSetInitialZoom,
    };
  };

  const clickOutsideHandle = (state, timelineElements, offsetXZeroOne) => {
    const range = state.right - state.left;
    let targetStart = Math.max(0, offsetXZeroOne - range * 0.5);
    let targetEnd = targetStart + range;
    if (targetEnd > 1) {
      targetEnd = 1;
      targetStart = targetEnd - range;
    }
    const initialStart = state.left;
    const initialEnd = state.right;
    timelineElements.overlayCanvas.dispatchEvent(new Event("interaction-begin"));
    animateToRange(
      initialStart,
      initialEnd,
      state.top,
      state.bottom,
      targetStart,
      targetEnd,
      state.top,
      state.bottom,
      200,
      (start, end, _top, _bottom, _final) => {
        state.left = start;
        state.right = end;
        timelineElements.overlayCanvas.dispatchEvent(
          new CustomEvent("range-change", {
            detail: {
              startZeroOne: state.left,
              endZeroOne: state.right,
              initialRender: false,
              force: false,
            },
          })
        );
      }
    ).then(() => {
      timelineElements.overlayCanvas.dispatchEvent(new Event("interaction-end"));
    });
  };

  const animate = async (callback) => {
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        callback();
        resolve();
      });
    });
  };

  const clamp = (val) => Math.min(1, Math.max(0, val));

  const smoothStep = (val) => {
    const t = clamp(val);
    return t * t * (3.0 - 2.0 * t);
  };

  const animateToRange = async (
    initialStart,
    initialEnd,
    initialTop,
    initialBottom,
    targetStart,
    targetEnd,
    targetTop,
    targetBottom,
    durationMs,
    update
  ) => {
    // TODO: Make max duration 200ms, but if the distance between the start range and the end range
    //  is small, make the duration relative to that.
    const startTime = performance.now();
    const endTime = startTime + durationMs;
    let tt = startTime;
    const startRange = targetStart - initialStart;
    const endRange = targetEnd - initialEnd;
    const topRange = targetTop - initialTop;
    const bottomRange = targetBottom - initialBottom;
    while (tt < endTime) {
      await animate(() => {
        // Map tt into zeroToOne space
        tt = performance.now();
        // Smoothly interpolate initialStart to targetStart over a given duration.
        const t = smoothStep(mapRange(tt, startTime, endTime, 0, 1));
        const startT = Math.max(0, initialStart + startRange * t);

        const endT = Math.min(1, initialEnd + endRange * t);
        const topT = Math.min(1, initialTop + topRange * t);
        const bottomT = Math.max(0, initialBottom + bottomRange * t);
        // update tween
        update(startT, endT, topT, bottomT, false);
      });
    }
    const forceRenderFinalFrame = true;
    await animate(() =>
      update(
        targetStart,
        targetEnd,
        targetTop,
        targetBottom,
        forceRenderFinalFrame
      )
    );
  };

  const FFT_WIDTH = 2048;
  const HEIGHT = FFT_WIDTH / 2; // Height needs to be at half the FFT width.
  const numWorkers = (navigator.hardwareConcurrency || 2) - 1;

  async function initWorkers(state) {
    if (state.workers.length === 0) {
      const remoteScriptOrigin = cdnScriptOrigin();
      const wasmUrl = remoteScriptOrigin ? `${remoteScriptOrigin}/pkg/spectastiq_bg.wasm` : new URL("./pkg/spectastiq_bg.wasm", (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('spectastiq-bundle.js', document.baseURI).href));
      const wasmLoader = fetch(wasmUrl);
      const initWorkers = [];
      for (let i = 0; i < numWorkers; i++) {
        const worker = new WorkerPromise(`fft-worker-${i}`, state);
        state.workers.push(worker);
      }
      const wasm = await (await wasmLoader).arrayBuffer();
      for (const worker of state.workers) {
        initWorkers.push(worker.init(wasm));
      }
      await Promise.all(initWorkers);
    }
  }

  const normalizeAudioBuffer = (buffer) => {
    // Find the peak amplitude in the buffer
    let peak = 0;
    for (let i = 0; i < buffer.length; i++) {
      const sample = Math.abs(buffer[i]);
      if (sample > peak) {
        peak = sample;
      }
    }

    // If there's no signal, return early
    if (peak === 0) return buffer;

    // Calculate the target amplitude for -3 dBFS
    const targetAmplitude = Math.pow(10, (-3) / 20); // Convert dB to linear scale

    // Calculate scaling factor
    const scaleFactor = targetAmplitude / peak;

    // Apply normalization to all samples
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] *= scaleFactor;
    }

    return buffer;
  };

  const getGainForRegion = (state, minZeroOne, maxZeroOne, minFreqZeroOne, maxFreqZeroOne) => {
    const fullSpectrogram = state.imageDatas[0].imageData;
    const sliceLen = FFT_WIDTH / 2;
    let max = 0;
    const numSlices = fullSpectrogram.length / sliceLen;
    const initialNoiseSliceNum = 0;
    const startingSlice = Math.max(initialNoiseSliceNum, Math.floor(numSlices * minZeroOne));
    const endingSlice = Math.floor(numSlices * maxZeroOne);
    const startSliceOffset = startingSlice * sliceLen;
    const endSliceOffset = endingSlice * sliceLen;
    const freqRange = Math.min(sliceLen, state.clip);
    const minFreqCutOff = Math.floor(freqRange * minFreqZeroOne);
    const maxFreqCutOff = Math.floor(freqRange * maxFreqZeroOne);
    for (
      let sliceNum = startSliceOffset;
      sliceNum < endSliceOffset;
      sliceNum += sliceLen
    ) {
      const slice = state.sharedOutputData.slice(sliceNum, sliceNum + sliceLen);
      for (let i = minFreqCutOff; i < maxFreqCutOff; i++) {
        const val = slice[i];
        max = Math.max(max, val);
      }
    }
    max = Math.min(max, state.max);
    const globalMax = Math.log10(state.max);
    const localMax = Math.log10(max);
    return globalMax / localMax;
  };

  const initSpectrogram = async (fileBytes, previousState) => {
    const state = {
      sharedFloatData: undefined,
      sharedOutputData: undefined,
      prevLeft: undefined,
      prevRight: undefined,
      max: undefined,
      imageDatas: [],
      canvasWidth: 0,
      pendingRender: {
        complete: true,
      },
      ctxs: (previousState && previousState.ctxs) || new Map(),
      firstRender: true,
      colorMap: 4,
      cropAmountTop: 0,
      cropAmountBottom: 0,
      workers: (previousState && previousState.workers) || [],
    };
    await initWorkers(state);
    // Normalise the audio to a peak of -3 dBFS
    const audioContext = (previousState && previousState.offlineAudioContext) || new OfflineAudioContext({
      length: 1024 * 1024,
      numberOfChannels: 1,
      sampleRate: 48000,
    });
    // TODO: Decode audio off main thread
    const wavData = await audioContext.decodeAudioData(fileBytes).catch((e) => {
      console.error(e);
    });
    if (!wavData) {
      return {
        error: 'Could not decode audio data',
      };
    }
    const floatData = wavData.getChannelData(0);
    // Sometimes we get malformed files that end in zeros  we want to truncate these.
    let actualEnd = floatData.length;
    for (let i = floatData.length - 1; i > -1; i--) {
      if (floatData[i] !== 0) {
        actualEnd = i;
        break;
      }
    }
    const actualFloatData = normalizeAudioBuffer(floatData.subarray(0, actualEnd));
    const audioFloatData = actualFloatData;
    if (!!window.SharedArrayBuffer) {
      state.sharedFloatData = new Float32Array(
        new SharedArrayBuffer(actualFloatData.byteLength)
      );
      state.sharedFloatData.set(actualFloatData, 0);
    } else {
      state.sharedFloatData = actualFloatData;
    }

    const invalidateCanvasCaches = () => {
      state.imageDatas = [];
      state.pendingRender.complete = true;
      state.max = undefined;
    };

    const terminateWorkers = (state) => {
      for (const worker of state.workers) {
        worker.terminate();
      }
    };

    return {
      renderRange: renderRange(state),
      renderToContext: renderToContext(state),
      audioFloatData,
      invalidateCanvasCaches,
      cyclePalette: () => cyclePalette(state),
      terminateWorkers: () => terminateWorkers(state),
      persistentSpectrogramState: {workers: state.workers, offlineAudioContext: audioContext, ctxs: state.ctxs},
      getGainForRegion: (startZeroOne, endZeroOne, minFreq, maxFreq) => getGainForRegion(state, startZeroOne, endZeroOne, minFreq, maxFreq),
    };
  };

  const drawImage = (state, ctx) => {
    if (ctx && !state.ctxs.get(ctx)) {
      state.ctxs.set(ctx, init(ctx));
    }
    return state.ctxs.get(ctx).drawImage;
  };
  const submitTexture = (state, ctx) => {
    if (ctx && !state.ctxs.get(ctx)) {
      state.ctxs.set(ctx, init(ctx));
    }
    return state.ctxs.get(ctx).submitTexture;
  };

  const colorMaps = ["Viridis", "Plasma", "Inferno", "Grayscale"];
  const cyclePalette = (state) => {
    state.colorMap++;
    if (state.colorMap >= colorMaps.length) {
      state.colorMap = 0;
    }
    return colorMaps[state.colorMap];
  };

  const renderRange =
    (state) => async (startZeroOne, endZeroOne, renderWidth, force) => {

      // NOTE: Min width for renders, so that narrow viewports don't get overly blurry images when zoomed in.
      renderWidth = Math.max(1920, renderWidth);
      if (startZeroOne === 0 && endZeroOne === 1) {
        if (state.imageDatas.length) {
          // We've already rendered the fully zoomed out version, no need to re-render
          return new Promise((resolve) => resolve());
        }
      }
      return new Promise((resolve) => {
        if (
          force ||
          startZeroOne !== state.prevLeft ||
          endZeroOne !== state.prevRight ||
          renderWidth !== state.canvasWidth
        ) {
          // Kick off this render of the full visible region at optimal resolution, as long as it's not already processing.
          // Once ready, stretch it as best we can to the visible region.
          if (state.pendingRender.complete || force) {
            state.pendingRender.complete = false;
            // Kick off a render at the current zoom level.
            const length = state.sharedFloatData.length;
            const startSample = Math.floor(length * startZeroOne);
            const endSample = Math.min(length, Math.ceil(length * endZeroOne));

            renderArrayBuffer(
              state,
              renderWidth,
              startZeroOne,
              endZeroOne,
              startSample,
              endSample
            ).then((s) => {
              state.prevLeft = startZeroOne;
              state.canvasWidth = renderWidth;
              state.prevRight = endZeroOne;
              state.pendingRender.complete = true;
              resolve(s);
            });
          } else {
            resolve();
          }
        } else {
          resolve();
        }
      });
    };

  const renderToContext =
    (state) =>
      async (
        ctx,
        startZeroOne,
        endZeroOne,
        top,
        bottom
      ) => {
        // Figure out the best intermediate render to stretch.
        // Do we store the final coloured imagedata to stretch, or the FFT array data?

        // Set best match to the full zoomed out range, then look for a better match
        let bestMatch = state.imageDatas[0];
        let exactMatch = false;
        let cropLeft = startZeroOne;
        let cropRight = endZeroOne;

        // Look first for an exact match.
        for (let i = 1; i < state.imageDatas.length; i++) {
          const data = state.imageDatas[i];
          if (
            data.startZeroOne === startZeroOne &&
            data.endZeroOne === endZeroOne
          ) {
            cropLeft = 0;
            cropRight = 1;
            // An exact match
            exactMatch = true;
            bestMatch = data;
            break;
          }
        }
        if (!exactMatch) {
          // Work out whether we're zooming out or in relative to the prev frame, or panning.
          if (state.imageDatas.length === 2) {
            let zoomingIn = false;
            // Look for a more zoomed out match
            for (let i = 1; i < state.imageDatas.length; i++) {
              const data = state.imageDatas[i];
              if (data.startZeroOne <= startZeroOne && data.endZeroOne >= endZeroOne) {
                zoomingIn = true;
                // Work out what proportion of the more zoomed out image we want.
                cropLeft = mapRange(
                  startZeroOne,
                  data.startZeroOne,
                  data.endZeroOne,
                  0,
                  1
                );
                cropRight = mapRange(
                  endZeroOne,
                  data.startZeroOne,
                  data.endZeroOne,
                  0,
                  1
                );
                bestMatch = data;
                break;
              }
            }

            if (!zoomingIn) {
              // If zooming out, or panning, synthesise a new image
              const prevImage = state.imageDatas[1];
              prevImage.endZeroOne - prevImage.startZeroOne;
            }
          }
        }
        const bitmap = bestMatch;
        if (bitmap) {
          const end = cropLeft + (cropRight - cropLeft);

          const bitmapIndex = bitmap.startZeroOne === 0 && bitmap.endZeroOne === 1 ? 0 : 1;

          // If range is 0..1
          bitmap.submitted = bitmap.submitted || new Map();
          if (!bitmap.submitted.has(ctx)) {
            submitTexture(state, ctx)(bitmapIndex, bitmap.imageData, bitmap.width, bitmap.height);
            bitmap.submitted.set(ctx, true);
          }
          drawImage(state, ctx)(
            bitmapIndex,
            bitmap.normalizationScale,
            cropLeft,
            end,
            top,
            bottom,
            state.cropAmountTop,
            state.cropAmountBottom,
            state.colorMap
          );
          return state;
        }
      };

  const cdnScriptOrigin = () => {
    const spectastiqIsLoadedFromCdn = Array.from(document.getElementsByTagName('script'))
      .find(el => el.src.startsWith("https://cdn.jsdelivr.net/gh/hardiesoft/spectastiq"));
    if (spectastiqIsLoadedFromCdn) {
      const cdnStub = spectastiqIsLoadedFromCdn.src.split("/");
      cdnStub.pop();
      return cdnStub.join("/");
    }
    return false;
  };

  class WorkerPromise {
    constructor(name) {
      this.name = name;
      const remoteScriptOrigin = cdnScriptOrigin();
      if (remoteScriptOrigin) {
        // Use the bundled/non-module version of the worker using importScripts
        this.worker = this.worker = new Worker(
          URL.createObjectURL(
            new Blob(
              [
                `importScripts("${remoteScriptOrigin}/worker-bundle.min.js")`,
              ],
              {type: "text/javascript"}
            )),
          {type: "classic"}
        );
      } else {
        this.worker = new Worker(
          new URL("./spectastiq-worker.js", (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('spectastiq-bundle.js', document.baseURI).href)),
          {type: "module", credentials: "same-origin"}
        );
      }
      this.worker.onmessage = ({data}) => {
        if ((!window.SharedArrayBuffer) && data.output) {
          // Copy outputs back to state.sharedOutputData in the correct offsets
          this.output.subarray(data.offsets.outStart, data.offsets.outEnd).set(data.output, 0);
        }
        // Resolve;
        this.work[data.id](data);
        delete this.work[data.id];
      };
      this.work = {};
      this.id = 0;
    }

    doWork(data, output) {
      if (output) {
        this.output = output;
      }
      return new Promise((resolve) => {
        const jobId = this.id;
        this.id++;
        this.work[jobId] = resolve;
        const message = {id: jobId, ...data};
        try {
          this.worker.postMessage(message);
        } catch (e) {
          console.warn(e);
        }
      });
    }

    init(wasm) {
      return this.doWork({
        type: "Init",
        name: this.name,
        wasm,
      });
    }

    terminate() {
      this.worker.terminate();
    }
  }

  async function renderArrayBuffer(
    state,
    canvasWidth,
    startZeroOne,
    endZeroOne,
    startSample,
    endSample
  ) {
    const widthChanged = canvasWidth !== state.canvasWidth;
    const numChunks = numWorkers;
    const canvasChunkWidth = Math.ceil(canvasWidth / numChunks);

    if (!state.sharedOutputData || widthChanged) {
      if (!state.sharedOutputData || canvasWidth > state.canvasWidth) {
        // Realloc on resize
        if (!!window.SharedArrayBuffer) {
          state.sharedOutputData = new Float32Array(
            new SharedArrayBuffer(canvasChunkWidth * numChunks * 4 * HEIGHT)
          );
        } else {
          state.sharedOutputData = new Float32Array(
            new ArrayBuffer(canvasChunkWidth * numChunks * 4 * HEIGHT)
          );
        }
      }
    }

    const audioChunkLength = Math.ceil((endSample - startSample) / numChunks);
    const canvasChunkLength = canvasChunkWidth * (FFT_WIDTH / 2);
    const job = [];
    let chunk = 0;
    let chunkStart = startSample;
    let outStart = 0;
    while (chunkStart < endSample) {
      const chunkEnd = Math.min(chunkStart + audioChunkLength, endSample);
      const outEnd = Math.min(
        outStart + canvasChunkLength,
        state.sharedOutputData.length
      );

      // Pass in 1 FFT window width as the prelude, so that we don't get a period of no output at the beginning of the slice
      const preludeStart = Math.max(0, chunkStart - FFT_WIDTH);
      const preludeEnd = Math.min(preludeStart + FFT_WIDTH, chunkStart);
      const work = {
        type: "Process",
        data: state.sharedFloatData.subarray(chunkStart, chunkEnd),
        prelude: state.sharedFloatData.subarray(preludeStart, preludeEnd),
        offsets: {outStart, outEnd}
      };
      if (!!window.SharedArrayBuffer) {
        work.output = state.sharedOutputData.subarray(outStart, outEnd);
      }
      job.push(
        state.workers[chunk].doWork(work, state.sharedOutputData)
      );
      chunk++;
      outStart += canvasChunkLength;
      chunkStart += audioChunkLength;
    }
    // NOTE: Interestingly, if we support streaming the audio in,
    //  we don't know what the maxes are ahead of time...
    // NOTE: Maxes are what we use to normalise on.

    // NOTE: We may *need* to support streaming audio chunks for longer audio clips?

    // FIXME - Only grab the maxes once, at startup? It's possible there are smaller sounds that aren't captured at that zoom
    //  level, and the max may need to be adjusted though.
    await Promise.all(job);
    if (state.firstRender) {
      // Work out the actual clipping
      state.firstRender = false;
      // NOTE: Try to find the actual sample rate of the audio if it's been resampled.
      const sliceLen = FFT_WIDTH / 2;
      const negs = [];

      // Starting 100 pixels/slices into the audio
      for (
        let j = sliceLen * 100;
        j < state.sharedOutputData.length;
        j += sliceLen
      ) {
        const slice = state.sharedOutputData.slice(j, j + sliceLen);
        for (let i = slice.length - 1; i > -1; i--) {
          // TODO: May need to tune this threshold for very quiet audio files?
          if (slice[i] > 10000) {
            negs.push(i);
            break;
          }
        }
      }
      negs.sort();
      const clip = Math.min(negs[Math.floor(negs.length / 2)], FFT_WIDTH / 2);
      const cClip = FFT_WIDTH / 2 - clip;
      const clipPercent = 1 - (cClip / (FFT_WIDTH / 2));
      state.actualSampleRate = 48000 * clipPercent;
      state.cropAmountTop = 1 - clipPercent;
      state.clip = clip;

    }
    if (!state.max) {
      // Maybe we need to calculate the min/maxes here after cropping anyway?
      // We remove values at the top of the clip less than 10,000
      const sliceLen = FFT_WIDTH / 2;
      let min = Number.MAX_VALUE;
      let max = 0;
      // NOTE: Don't use the very beginning of the file, sometimes they have weird noise
      for (
        let j = 100;
        j < state.sharedOutputData.length;
        j += sliceLen
      ) {
        // NOTE: Crop off noise floor.
        const slice = state.sharedOutputData.slice(j, j + sliceLen);
        // console.log("noise floor", (12 /1024) * state.actualSampleRate);
        // TODO: Work out actual frequency cutoff of around 500hz
        const m = Math.min(slice.length, state.clip);
        for (let i = 12; i < m; i++) {
          const val = slice[i];
          min = Math.min(min, val);
          max = Math.max(max, val);
        }
      }
      state.min = min;
      state.max = max;
    }
    // TODO: Once we know how we're cropping etc, work out min/max values and translate that to a volume scale.
    //  Also allow doing this *again* for a zoomed region of interest.
    // noinspection JSSuspiciousNameCombination
    const nextImageData = {
      startZeroOne,
      endZeroOne,
      imageData: new Float32Array(state.sharedOutputData),
      normalizationScale: state.max,
      width: HEIGHT,
      height: canvasChunkWidth * numChunks,
    };

    if (state.imageDatas.length === 0) {
      state.imageDatas = [nextImageData];
    } else if (state.imageDatas.length === 1) {
      state.imageDatas.push(nextImageData);
    } else {
      state.imageDatas[1] = nextImageData;
    }
    return {
      actualSampleRate: state.actualSampleRate,
      cropAmountTop: state.cropAmountTop,
    };
  }

  const initAudioPlayer = (
    root,
    sharedState,
    timelineState,
    playerElements,
  ) => {
    const audioContext = new AudioContext({ sampleRate: 48000 });
    const gainNode = audioContext.createGain();
    const filterNode = audioContext.createBiquadFilter();
    filterNode.type = "allpass";
    const volume = 1.0;
    setGain(gainNode, volume);

    const state = {
      audioNodes: {
        gainNode,
        filterNode,
      },
      audioContext,
      audioProgressZeroOne: 0,
      playbackStartOffset: 0,
      progressSampleTime: 0,
      playing: false,
      audioStatusPoll: 0,
      capturedElement: null,
      wasPlaying: false,
      playheadStartOffsetXZeroOne: 0,
      playheadDragOffsetX: 0,
      followPlayhead: false,
      mainPlayheadStartOffsetXZeroOne: 0,
      mainPlayheadDragOffsetX: 0,
      dragPlayheadRaf: 0,
      playheadWasInRangeWhenPlaybackStarted: false,
      root,
    };

    playerElements.playButton.addEventListener("click", async () => {
      await togglePlayback(state, timelineState, sharedState, playerElements);
    });

    return {
      audioState: state,
      updatePlayhead: (beganPlaying = false, rangeChange = false, ) =>
        updatePlayhead(
          state,
          timelineState,
          sharedState,
          playerElements,
          beganPlaying,
          rangeChange
        ),
      setPlaybackOffset: (offsetZeroOne) =>
        setPlaybackTime(offsetZeroOne, state),
      setBandPass: (minFreq, maxFreq) =>
        setBandPass(filterNode, minFreq, maxFreq),
      removeBandPass: () => removeBandPass(filterNode),
      setGain: (volume) => setGain(gainNode, volume),
      pause: () => pauseAudio(state, timelineState, sharedState, playerElements),
      play: (startOffsetZeroOne, stopOffsetZeroOne) => playAudio(state, timelineState, sharedState, playerElements, startOffsetZeroOne, stopOffsetZeroOne),
      togglePlayback: () => togglePlayback(state, timelineState, sharedState, playerElements),
      startPlayheadDrag: () => startPlayheadDrag(state, timelineState, sharedState, playerElements),
      endPlayheadDrag: () => endPlayheadDrag(state, timelineState, sharedState, playerElements),
      dragLocalPlayhead: (x) => dragLocalPlayhead(x, state, timelineState, sharedState, playerElements),
      dragGlobalPlayhead: (x) => dragGlobalPlayhead(x, state, timelineState, sharedState, playerElements),
    };
  };

  const removeBandPass = (biQuadFilterNode) => {
    // Does this really turn things off properly?
    biQuadFilterNode.type = "allpass";
  };

  const setBandPass = (biQuadFilterNode, minFreq, maxFreq) => {
    minFreq = Math.min(maxFreq, Math.max(100, minFreq));
    biQuadFilterNode.type = "bandpass";
    const freqCenter = minFreq + (maxFreq - minFreq) * 0.5;
    const freqDelta = Math.max(100, maxFreq - minFreq);
    // This is how "wide" the filter bell-curve is around the center as a ratio?
    const QFactor = freqCenter / freqDelta;
    biQuadFilterNode.frequency.value = freqCenter;
    biQuadFilterNode.Q.value = QFactor;
  };

  const setGain = (gainNode, volume) => {
    gainNode.gain.value = volume;
    return gainNode.gain.value;
  };

  const startPlayheadDrag = (state, timelineState, sharedState, playerElements) => {
      state.wasPlaying = state.playing;
      if (state.playing) {
        pauseAudio(state, timelineState, sharedState, playerElements, state.audioProgressZeroOne);
      }
  };

  const endPlayheadDrag = (
    state,
    timelineState,
    sharedState,
    playerElements
  ) => {
    if (state.wasPlaying) {
      playAudio(state, timelineState, sharedState, playerElements, state.audioProgressZeroOne).then(() => {
        // Do nothing
      });
    }
  };


  const dragGlobalPlayhead = (xZeroOne, state, timelineState, sharedState, playerElements) => {
      const thisOffsetXZeroOne = Math.max(
        0,
        Math.min(xZeroOne, 1)
      );
      cancelAnimationFrame(state.dragPlayheadRaf);
      if (state.audioContext.state !== "running") {
        // Update the playhead anyway.
        state.audioProgressZeroOne = thisOffsetXZeroOne;
        updatePlayhead(state, timelineState, sharedState, playerElements);
      }
      state.dragPlayheadRaf = requestAnimationFrame(async () => {
        state.audioProgressZeroOne = thisOffsetXZeroOne;
        setPlaybackTime(thisOffsetXZeroOne, state).then(() => {
          updatePlayhead(state, timelineState, sharedState, playerElements);
        });
      });
  };

  const dragLocalPlayhead = (
    xZeroOne,
    state,
    timelineState,
    sharedState,
    playerElements
  ) => {
      const range = timelineState.right - timelineState.left;
      const thisOffsetXZeroOne = Math.min(
        timelineState.right,
        timelineState.left +
          Math.max(
            0,
            Math.min(range * xZeroOne, 1)
          )
      );
      cancelAnimationFrame(state.dragPlayheadRaf);
      if (state.audioContext.state !== "running") {
        // Update the playhead anyway.
        state.audioProgressZeroOne = thisOffsetXZeroOne;
        updatePlayhead(state, timelineState, sharedState, playerElements);
      }
      state.dragPlayheadRaf = requestAnimationFrame(async () => {
        state.audioProgressZeroOne = thisOffsetXZeroOne;
        //state.progressSampleTime = performance.now();
        setPlaybackTime(thisOffsetXZeroOne, state).then(() => {
          updatePlayhead(state, timelineState, sharedState, playerElements);
        });
      });
  };

  const setPlaybackTime = async (offsetZeroOne, state) => {
    if (state.audioDuration) {
      if (state.audioContext.state !== "running") {
        await state.audioContext.resume();
      }
      state.audioProgressZeroOne = offsetZeroOne;
      state.playbackStartTime = performance.now();
      state.playbackStartOffset = offsetZeroOne;
    }
  };

  const initAudio = (playerElements, audioFloatData, state) => {
    state.audioDuration = audioFloatData.length / 48000;
    const buffer = state.audioContext.createBuffer(1, audioFloatData.length, 48000);
    buffer.copyToChannel(audioFloatData, 0);
    state.audioBuffer = buffer;
  };

  const playAudio = async (state, timelineState, sharedState, playerElements, startAtOffsetZeroOne, stopAtOffsetZeroOne) => {
    if (state.playing) {
      pauseAudio(state, timelineState, sharedState, playerElements);
    }

    if (state.audioContext.state !== "running") {
      await state.audioContext.resume();
    }
    if (startAtOffsetZeroOne !== undefined) {
      state.audioProgressZeroOne = startAtOffsetZeroOne;
    }
    state.audioNodes.bufferNode = state.audioContext.createBufferSource();
    state.audioNodes.bufferNode.buffer = state.audioBuffer;
    state.audioNodes.bufferNode
      .connect(state.audioNodes.filterNode)
      .connect(state.audioNodes.gainNode)
      .connect(state.audioContext.destination);

    const startOffset = state.audioProgressZeroOne * state.audioDuration;

    const playbackLatency = state.audioContext.outputLatency || state.audioContext.baseLatency || 0;
    if (stopAtOffsetZeroOne !== undefined) {
      const endOffset = stopAtOffsetZeroOne * state.audioDuration;
      const secondsToPlay = endOffset - startOffset;

      state.endOffsetZeroOne = stopAtOffsetZeroOne;
      state.startOffsetZeroOne = state.audioProgressZeroOne;

      state.audioNodes.bufferNode.start(0, startOffset, secondsToPlay);
      state.playbackStartTime = performance.now() + playbackLatency;
      state.expectedPlaybackEnd = state.playbackStartTime + (secondsToPlay * 1000);
    } else {
      delete state.endOffsetZeroOne;
      state.audioNodes.bufferNode.start(0, startOffset);
      state.playbackStartTime = performance.now() + playbackLatency;
      state.expectedPlaybackEnd = state.playbackStartTime + (state.audioDuration * 1000);
    }
    state.playing = true;
    state.playbackStartOffset = state.audioProgressZeroOne;

    playerElements.playButton.classList.remove("paused");
    updatePlayhead(state, timelineState, sharedState, playerElements);
    state.root.dispatchEvent(
      new Event("playback-started", {
        bubbles: false,
        composed: true,
        cancelable: false,
      })
    );
  };
  const pauseAudio = (state, timelineState, sharedState, playerElements) => {
    if (state.playing) {
      cancelAnimationFrame(state.audioStatusPoll);
      state.audioStatusPoll = 0;
      state.playing = false;
      state.audioNodes.bufferNode.stop();
      playerElements.playButton.classList.add("paused");
      state.root.dispatchEvent(
        new Event("playback-ended", {
          bubbles: false,
          composed: true,
          cancelable: false,
        })
      );
    }
  };

  const updatePlayhead = (
    state,
    timelineState,
    sharedState,
    playerElements,
    beganPlaying = false,
    rangeChange = false,
  ) => {
    const {
      playheadCanvasCtx,
      mainPlayheadCanvasCtx,
    } = playerElements;
    const lastProgress = state.audioProgressZeroOne;
    const elapsedSincePlaybackStarted = state.playing ? (performance.now() - (state.playbackStartTime || performance.now())) / 1000 : 0;
    if (state.playing) {
      state.audioProgressZeroOne = Math.max(0, Math.min(1, ((state.playbackStartOffset * state.audioDuration) + elapsedSincePlaybackStarted) / state.audioDuration));
    }
    if (state.playing && (state.audioProgressZeroOne === 1 || performance.now() > state.expectedPlaybackEnd)) {
      pauseAudio(state, timelineState, sharedState, playerElements);
      if (state.endOffsetZeroOne !== undefined) {
        state.audioProgressZeroOne = state.endOffsetZeroOne;
      } else {
        // Make sure we don't overshoot
        state.audioProgressZeroOne = lastProgress;
      }
    }
    const playheadWidth = Math.min(2, 1.5);
    const progress = state.audioProgressZeroOne;
    playheadCanvasCtx.clearRect(0, 0, playheadCanvasCtx.canvas.width, playheadCanvasCtx.canvas.height);
    mainPlayheadCanvasCtx.clearRect(0, 0, mainPlayheadCanvasCtx.canvas.width, mainPlayheadCanvasCtx.canvas.height);
    if (!Number.isNaN(progress)) {
      if (!rangeChange) {
        // Redraw the minimap playhead on its canvas at the correct offset position.
        const width = playheadCanvasCtx.canvas.width;
        const height = playheadCanvasCtx.canvas.height;
        playheadCanvasCtx.fillStyle = timelineState.isDarkTheme ? `rgba(204, 204, 204, 0.8)` : `rgba(0, 0, 0, 0.8)`;

        // Draw the global playhead position
        const left = Math.min(width - playheadWidth - 1, Math.max(-playheadWidth / 2, progress * width - playheadWidth/2));
        playheadCanvasCtx.fillRect(left, 0, playheadWidth, height);
      }
      {
        const fourPx = 4 * devicePixelRatio;
        const threePx = 3 * devicePixelRatio;
        const tenPx = 10 * devicePixelRatio;
        const width = mainPlayheadCanvasCtx.canvas.width;
        const height = mainPlayheadCanvasCtx.canvas.height;
        mainPlayheadCanvasCtx.clearRect(0, 0, width, height);
        mainPlayheadCanvasCtx.fillStyle = timelineState.isDarkTheme ? `rgba(204, 204, 204, 1)` : `rgba(0, 0, 0, 1)`;
        const drawPlayheadScrubHandles = (opacity) => {
          const audioProgressZeroOne = progress;
          const ctx = mainPlayheadCanvasCtx;
          const startZeroOne = timelineState.left;
          const endZeroOne = timelineState.right;
          const height = ctx.canvas.height;
          const center = Math.min(audioProgressZeroOne * width, width - 1);
          ctx.beginPath();
          ctx.moveTo(center, height);
          ctx.lineTo(center - fourPx, height - threePx);
          ctx.lineTo(center - fourPx, height - tenPx);
          ctx.lineTo(center + fourPx, height - tenPx);
          ctx.lineTo(center + fourPx, height - threePx);
          ctx.lineTo(center, height);
          ctx.fill();
          ctx.beginPath();
          // TODO: Use timelineState.inGlobalPlaybackScrubberHandle and timelineState.inLocalPlaybackScrubberHandle
          //  to show down/hover states for scrubber handles.
          if (timelineState.isDarkTheme) {
            ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
            ctx.moveTo(center, height);
            ctx.lineTo(center - fourPx, height - threePx);
            ctx.lineTo(center - fourPx, height - tenPx);
            ctx.lineTo(center, height - tenPx);
            ctx.lineTo(center, height);
            ctx.fill();
          } else {
            ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
            ctx.moveTo(center, height);
            ctx.lineTo(center + fourPx, height - threePx);
            ctx.lineTo(center + fourPx, height - tenPx);
            ctx.lineTo(center, height - tenPx);
            ctx.lineTo(center, height);
            ctx.fill();
          }

          {
            ctx.fillStyle = timelineState.isDarkTheme ? `rgba(204, 204, 204, ${opacity})` : `rgba(0, 0, 0, ${opacity})`;
            const localProgress = (audioProgressZeroOne - startZeroOne) / (endZeroOne - startZeroOne);
            const center = localProgress * width;
            const height = tenPx + 0.5;
            ctx.beginPath();
            ctx.moveTo(center, height);
            ctx.lineTo(center - fourPx, height - threePx);
            ctx.lineTo(center - fourPx, height - tenPx);
            ctx.lineTo(center + fourPx, height - tenPx);
            ctx.lineTo(center + fourPx, height - threePx);
            ctx.lineTo(center, height);
            ctx.fill();
            ctx.beginPath();
            if (timelineState.isDarkTheme) {
              ctx.fillStyle = `rgba(0, 0, 0, ${Math.min(opacity, 0.15)})`;
              ctx.moveTo(center, height);
              ctx.lineTo(center - fourPx, height - threePx);
              ctx.lineTo(center - fourPx, height - tenPx);
              ctx.lineTo(center, height - tenPx);
              ctx.lineTo(center, height);
              ctx.fill();
            } else {
              ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(opacity, 0.25)})`;
              ctx.moveTo(center, height);
              ctx.lineTo(center + fourPx, height - threePx);
              ctx.lineTo(center + fourPx, height - tenPx);
              ctx.lineTo(center, height - tenPx);
              ctx.lineTo(center, height);
              ctx.fill();
            }
          }
        };

        const playheadInRange =
          progress >= timelineState.left && progress <= timelineState.right;

        if (state.playing) {
          state.audioStatusPoll = requestAnimationFrame(() => {
            updatePlayhead(state, timelineState, sharedState, playerElements);
          });
        }
        state.root.dispatchEvent(
          new CustomEvent("playhead-update", {
            bubbles: false,
            composed: true,
            cancelable: false,
            detail: {
              timeInSeconds: (progress * state.audioDuration)
            }
          })
        );
        const range = timelineState.right - timelineState.left;
        let opacity = 1;
        if (range >= 0.75) {
          opacity = mapRange(range, 0.75, 1, 1, 0.1);
        }
        if (playheadInRange) {
          drawPlayheadScrubHandles(opacity);
          mainPlayheadCanvasCtx.fillStyle = timelineState.isDarkTheme ? `rgba(204, 204, 204, ${opacity})` : `rgba(0, 0, 0, ${opacity})`;
          // Draw the local (zoomed area) playhead position
          const pro = (progress - timelineState.left) / range;
          const left = Math.max(0, Math.min(width - playheadWidth, pro * width - playheadWidth / 2));
          state.followPlayhead = true;
          mainPlayheadCanvasCtx.fillRect(left, tenPx + 0.5, playheadWidth, height);
          // NOTE: Advance range if playhead was inside range when playback started.
        } else if (state.followPlayhead && !sharedState.interacting) {
          const range = timelineState.right - timelineState.left;
          timelineState.right = Math.min(1, timelineState.right + range);
          timelineState.left = timelineState.right - range;
          drawPlayheadScrubHandles();

          playerElements.overlayCanvas.dispatchEvent(
            new CustomEvent("range-change", {
              detail: {
                startZeroOne: timelineState.left,
                endZeroOne: timelineState.right,
              },
            })
          );
        } else {
          drawPlayheadScrubHandles(opacity);
          state.followPlayhead = false;
        }
      }
    }
  };

  const togglePlayback = async (state, timelineState, sharedState, playerElements) => {
    if (!state.playing) {
      await playAudio(state, timelineState, sharedState, playerElements);
    } else {
      pauseAudio(state, timelineState, sharedState, playerElements);
    }
    return state.playing;
  };

  const template = document.createElement("template");
  template.innerHTML = `
<style>
  * {
    box-sizing: border-box;
  }     
  #container {
    background: transparent;                          
    display: flex;
    position: relative;
    flex-direction: column;
    opacity: 1;
    
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;   
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;                    
  }
  #container:focus {
    /*outline: none;*/
  }
  #container canvas {
    opacity: 1;
    transition: opacity 0.5s;
  }
  #container.loading {
    touch-action: none;
    user-select: none;
    pointer-events: none; 
  }
  #container.disabled {
    touch-action: none;
    user-select: none;
    pointer-events: none; 
  }
  #container.loading canvas {
    opacity: 0;
  }
  #container.disabled canvas {
    opacity: 0.5;
  }
  #spectrogram-container {
    position: relative;
    cursor: grab;
  }
  #spectrogram-container.cursor-pointer {
    cursor: pointer; 
  }
  #spectrogram-container.dragging {
    cursor: grabbing; 
  } 
  #spectrogram-container.custom-interaction-mode {
    cursor: unset;
  }
  #canvas-container {
    position: relative;
    height: 300px;
  }
  #spectrogram-canvas, #spectastiq-overlay-canvas, #user-overlay-canvas {
    position: absolute;
    top: 0;
    left: 0;
    margin: 0;
    padding: 0;
    touch-action: none;
    user-select: none;           
  }
  #spectastiq-timescale-overlay-canvas {
    position: absolute;
    top: 0;
    left: 0;
    touch-action: none;
    user-select: none;
  }  
  #main-playhead-canvas, #user-overlay-canvas, #spectrogram-canvas {
    margin: 0;
    padding: 0;
    position: absolute;
    touch-action: none;
    user-select: none;
    pointer-events: none;
  }
  
  #timeline-ui-canvas.grab {
    cursor: grab;
  }
  #timeline-ui-canvas.resize {
    cursor: ew-resize;
  }
  #timeline-ui-canvas.grabbing {
    cursor: grabbing;
  }
  #playhead-canvas, #map-canvas {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: 0;
    z-index: 1;
    user-select: none;
    touch-action: none;
    pointer-events: none;
  }
  #timeline-ui-canvas {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: 0;
    z-index: 1;
    touch-action: none;
    user-select: none;
    cursor: pointer;
  }
  #mini-map {         
    height: 60px;
    position: relative;
    margin: 0;
    touch-action: none;
    user-select: none;
  }  
  #container:not(.audio-loaded) #mini-map, #container:not(.audio-loaded) #canvas-container {
    pointer-events: none;    
  }
  #container:not(.audio-loaded) #spectrogram-container {
    cursor: default;
  }
  .select-user-file, .select-user-file input, .error-message-container {
    display: none;
  }
  #container.no-src .select-user-file, #container.error .error-message-container {   
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;  
  }
  .error-message {
    background: darkred;
    color: white;
    font-family: sans-serif;
    padding: 5px 5px 5px 7px;
    border-radius: 3px;
    font-size: 14px;
    box-shadow: #111 0 2px 3px;
  }
  .error-message pre {
    background: rgba(0, 0, 0, 0.5);
    display: inline-block;
    color: #ddd;
    padding: 3px;
    margin: 0;
    font-size: 13px;
    border-radius: 3px;
  }
  #controls {   
    display: flex;                   
    background: lightslategray;
  }
  #controls.disabled {
    pointer-events: none;
  }
  #default-controls {
    padding: 10px;
  }
  .control-button {
    all: unset;
    width: 44px;
    height: 44px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    background: azure;
    border: 1px solid darkslateblue;
    border-radius: 3px;
    color: darkslateblue;
  }
  .play-toggle.paused > .pause-icon {
    display: none;
  }
  .play-toggle:not(.paused) > .play-icon {
    display: none;
  }
  .play-toggle:disabled {
    opacity: 0.5;
  }
     
  .lds-ring {
    display: inline-block;
    position: absolute;
    left: calc(50% - 40px);      
    width: 80px;
    height: 80px;
    top: calc(50% - 40px);             
  }
  #progress-bar {
    display: inline-block;
    position: absolute;
    left: calc(50% - 60px);      
    width: 120px;   
    top: calc(50% + 50px);   
  }
  .lds-ring div {
    box-sizing: border-box;
    display: block;
    position: absolute;
    width: 64px;
    height: 64px;
    margin: 8px;
    border-width: 8px;
    border-style: solid;
    border-radius: 50%;
    animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    border-color: #fff transparent transparent transparent;
  }
  .lds-ring div:nth-child(1) {
    animation-delay: -0.45s;
  }
  .lds-ring div:nth-child(2) {
    animation-delay: -0.3s;
  }
  .lds-ring div:nth-child(3) {
    animation-delay: -0.15s;
  }
  @keyframes lds-ring {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
</style>
<div id="container">
  <div id="spectrogram-container">
    <div id="canvas-container">
      <canvas height="300" id="spectrogram-canvas"></canvas>
      <canvas height="300" id="user-overlay-canvas"></canvas>
      <canvas height="30" id="spectastiq-timescale-overlay-canvas"></canvas>        
      <canvas height="300" id="spectastiq-overlay-canvas"></canvas>
      <canvas height="300" id="main-playhead-canvas"></canvas>                
    </div>
    <div id="mini-map">
      <canvas height="60" id="map-canvas"></canvas>     
      <canvas height="60" id="playhead-canvas"></canvas>
      <canvas height="60" id="timeline-ui-canvas"></canvas>         
    </div>
    <progress id="progress-bar" max="100"></progress>
    <div class="lds-ring" id="loading-spinner">
      <div></div>
      <div></div>
      <div></div>
      <div></div>
    </div>   
    <div class="select-user-file">
      <button class="select-user-file-btn">Open local audio file</button>
      <input type="file" accept="audio/*" class="select-user-file-input" />
    </div>
    <div class="error-message-container">
      <span class="error-message"></span>
    </div>
  </div>
  <div id="controls">
    <slot name="player-controls">
      <div id="default-controls">
        <button class="play-toggle control-button paused" disabled id="play-button">
          <svg class="play-icon" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 384 512"><path fill="currentColor" d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg>
          <svg class="pause-icon" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512"><path fill="currentColor" d="M48 64C21.5 64 0 85.5 0 112V400c0 26.5 21.5 48 48 48H80c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H48zm192 0c-26.5 0-48 21.5-48 48V400c0 26.5 21.5 48 48 48h32c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H240z"/></svg>
        </button>
      </div>
    </slot>
  </div>
</div>
`;

  class Spectastiq extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({mode: "open"});
    }

    inited = false;
    sharedState = {interacting: false};

    static observedAttributes = [
      "src",
      "height",
      "time-scale",
      "frequency-scale",
      "color-scheme",
      "colour-scheme",
    ];

    attributeChangedCallback(name, oldValue, newValue) {
      if (this.inited) {
        switch (name) {
          case "src": {
            newValue && this.loadSrc(newValue);
          }
            break;
          case "height": {
            const totalHeight = Number(newValue) || 360;
            this.timelineHeight = Math.min(60, Math.max(44, totalHeight - 200));
            this.spectrogramHeight = totalHeight - this.timelineHeight;
            // Resize.
            this.resizeCanvases(undefined, false);
          }
            break;
          case "time-scale": {
            this.drawTimescale = this.timeScale;
            if (this.drawTimescale) {
              this.redrawTimescaleOverlay();
            } else {
              this.clearTimescaleOverlay();
            }
          }
            break;
          case "frequency-scale": {
            this.drawFrequencyScale = this.frequencyScale;
            if (this.drawFrequencyScale) {
              this.redrawFrequencyScaleOverlay();
            } else {
              this.clearOverlay();
            }
            if (this.drawTimescale) {
              this.redrawTimescaleOverlay();
            }
          }
            break;
          case "color-scheme":
          case "colour-scheme": {
            if (
              !colorMaps
                .map((p) => p.toLowerCase())
                .includes(newValue.toLowerCase())
            ) {
              console.error(
                `Unknown color scheme: ${newValue}. Allowed schemes are any of '${colorMaps.join(
                "', '"
              )}'`
              );
              return;
            }
            while (
              this.nextPalette().toLowerCase() !==
              this.colorScheme.toLowerCase()
              ) {
              // Cycle until we get the desired palette
            }
          }
            break;
        }
      }
    }

    listColorSchemes() {
      return colorMaps;
    }

    connectedCallback() {
      this.init();
    }

    disconnectedCallback() {
      this.terminateWorkers && this.terminateWorkers();
      this.terminateWorkers = null;
      this.pause();
      this.unload();
    }

    get src() {
      return this.getAttribute("src");
    }

    set src(newValue) {
      this.setAttribute("src", newValue);
    }

    get height() {
      return this.getAttribute("height");
    }

    set height(newValue) {
      this.setAttribute("height", newValue);
    }

    get timeScale() {
      if (this.hasAttribute("time-scale")) {
        const scale = this.getAttribute("time-scale");
        return scale !== "false" && scale !== "0" && scale !== null;
      }
      return false;
    }

    set timeScale(newValue) {
      this.setAttribute("time-scale", newValue);
    }

    get frequencyScale() {
      if (this.hasAttribute("frequency-scale")) {
        const scale = this.getAttribute("frequency-scale");
        return scale !== "false" && scale !== "0" && scale !== null;
      }
      return false;
    }

    set frequencyScale(newValue) {
      this.setAttribute("frequency-scale", newValue);
    }

    get colorScheme() {
      return (
        this.getAttribute("color-scheme") || this.getAttribute("colour-scheme")
      );
    }

    set colorScheme(newValue) {
      // TODO: Make sure it's an allowed colour scheme, otherwise throw a warning.
      this.setAttribute("color-scheme", newValue);
    }

    set colourScheme(newValue) {
      // TODO: Make sure it's an allowed colour scheme, otherwise throw a warning.
      this.setAttribute("color-scheme", newValue);
    }

    unload() {
      this.requestAborted = true;
    }

    loadSrc(src) {
      const startTimeOffset = Number(this.getAttribute("start")) || 0;
      const endTimeOffset = Number(this.getAttribute("end")) || 1;
      const delegateDoubleClick = this.getAttribute("delegate-double-click");
      this.applicationHandlesDoubleClick = delegateDoubleClick !== "false" && delegateDoubleClick !== "0" && delegateDoubleClick !== null;
      const requestHeaders = this.getAttribute("request-headers");
      let headers = {};
      if (requestHeaders) {
        try {
          headers = JSON.parse(requestHeaders);
        } catch (e) {
          console.error(`Malformed JSON passed for request headers: ${e}`);
        }
      }
      const {drawTimelineUI, timelineState, setInitialZoom} = this.timeline;
      const {audioState, updatePlayhead} = this.audioPlayer;
      const canvas = this.timelineElements.canvas;
      const mapCtx = this.timelineElements.mapCanvas.getContext("webgl2");
      const ctx = canvas.getContext("webgl2");
      const timescaleOverlayContext =
        this.timelineElements.timescaleCanvas.getContext("2d");
      const userOverlayCtx =
        this.timelineElements.userOverlayCanvas.getContext("2d");
      this.progressBar.setAttribute("value", String(0));

      const MAX_ZOOMED_REGION = 0.8;
      const TEXTURE_HEIGHT = 1024;
      const map = (value, min1, max1, min2, max2) => {
        return min2 + ((value - min1) * (max2 - min2)) / (max1 - min1);
      };
      this.sharedState.interacting = false;
      (async () => {
        if (audioState && audioState.playing) {
          this.pause();
        }
        this.unload();
        this.beginLoad();

        // Download audio file and update the progress bar.
        let fileBytes;
        {
          const chunks = [];
          let receivedLength = 0;
          this.requestAborted = false;
          if (this.abortController) {
            this.abortController.abort("User aborted");
          }
          this.abortController = new AbortController();
          this.abortController.signal.addEventListener("onabort", () => {
            this.requestAborted = true;
          });
          const requestInfo = {
            mode: "cors",
            cache: "no-cache",
            method: "get",
            signal: this.abortController.signal,
            headers: {
              ...headers,
            },
          };
          let downloadAudioResponse;
          try {
            downloadAudioResponse = await fetch(src, requestInfo);
            if (!downloadAudioResponse.ok) {
              this.showErrorMessage(`Audio file not found <pre>${src}</pre>`);
            } else {
              if (!this.inited) {
                // Put this after the fetch otherwise we can never catch it fast enough.
                // FIXME: Even so, this doesn't fire in chrome for listeners in time.
                this.shadowRoot.dispatchEvent(
                  new Event("ready", {
                    composed: true,
                    bubbles: false,
                    cancelable: false,
                  })
                );
                this.inited = true;
              }
              const reader = downloadAudioResponse.body.getReader();
              let expectedLength = parseInt(
                downloadAudioResponse.headers.get("Content-Length"),
                10
              );
              if (isNaN(expectedLength)) {
                expectedLength = parseInt(
                  downloadAudioResponse.headers.get("Fallback-Content-Length"),
                  10
                );
              }
              if (!isNaN(expectedLength)) {
                if (!this.progressBar.parentElement) {
                  this.timelineElements.spectrogramContainer.appendChild(
                    this.progressBar
                  );
                }
              }
              while (!this.requestAborted) {
                const {done, value} = await reader.read();
                if (done) {
                  break;
                }
                chunks.push(value);
                receivedLength += value.length;
                if (!isNaN(expectedLength)) {
                  const progress = receivedLength / expectedLength;
                  this.progressBar.setAttribute("value", String(progress * 100));
                  if (progress === 1) {
                    if (this.progressBar.parentElement) {
                      this.progressBar.parentElement.removeChild(this.progressBar);
                    }
                  }
                }
              }
              const fileBytesReceived = new Uint8Array(receivedLength);
              let position = 0;
              for (const chunk of chunks) {
                fileBytesReceived.set(chunk, position);
                position += chunk.length;
              }
              fileBytes = fileBytesReceived.buffer;
              const spectrogramInited = await initSpectrogram(
                fileBytes,
                this.persistentSpectrogramState || null
              );
              if (spectrogramInited.error) {
                this.showErrorMessage(`${spectrogramInited.error} for <pre>${this.localSrc || src}</pre>`);
              } else {
                const {
                  renderRange,
                  renderToContext,
                  audioFloatData,
                  invalidateCanvasCaches,
                  terminateWorkers,
                  cyclePalette,
                  getGainForRegion,
                  persistentSpectrogramState,
                } = spectrogramInited;
                this.getGainForRegionOfInterest = getGainForRegion;
                timelineState.numAudioSamples = audioFloatData.length;
                timelineState.left = 0;
                timelineState.top = 1;
                timelineState.bottom = 0;
                timelineState.right = 1;
                timelineState.zoomX = 1;
                timelineState.pinchStarted = false;
                timelineState.panStarted = false;
                timelineState.initialPinchXLeftZeroOne = 0;
                timelineState.initialPinchXRightZeroOne = 1;
                timelineState.currentAction = null;
                audioState.followPlayhead = false;
                audioState.audioProgressZeroOne = 0;
                audioState.playbackStartOffset = 0;
                audioState.audioProgressSampleTime = performance.now();
                audioState.wasPlaying = false;
                audioState.playheadStartOffsetXZeroOne = 0;
                audioState.playheadDragOffsetX = 0;
                audioState.mainPlayheadStartOffsetXZeroOne = 0;
                audioState.mainPlayheadDragOffsetX = 0;
                audioState.dragPlayheadRaf = 0;
                audioState.playheadWasInRangeWhenPlaybackStarted = false;

                this.persistentSpectrogramState = persistentSpectrogramState;
                this.terminateWorkers = terminateWorkers;
                this.invalidateCanvasCaches = invalidateCanvasCaches;
                this.renderRange = renderRange;

                const defaultPalette = "Viridis";
                // Select starting palette
                let palette = this.colorScheme || defaultPalette;
                if (
                  !colorMaps
                    .map((p) => p.toLowerCase())
                    .includes(palette.toLowerCase())
                ) {
                  console.error(
                    `Unknown color scheme: ${palette}. Allowed schemes are any of '${colorMaps.join(
                    "', '"
                  )}'`
                  );
                  palette = defaultPalette;
                }
                let paletteChangeTimeout;
                this.nextPalette = () => {
                  this.clearOverlay();
                  const nextPalette = cyclePalette();
                  // Give downstream renderers a moment to adjust to palette changes;
                  clearTimeout(paletteChangeTimeout);
                  paletteChangeTimeout = setTimeout(() => {
                    timelineState.isDarkTheme = nextPalette !== "Grayscale";
                    const startZeroOne = timelineState.left;
                    const endZeroOne = timelineState.right;
                    const top = timelineState.top;
                    const bottom = timelineState.bottom;
                    drawTimelineUI(
                      startZeroOne,
                      endZeroOne,
                      timelineState.currentAction
                    );
                    renderToContext(ctx, startZeroOne, endZeroOne, top, bottom);
                    renderToContext(mapCtx, 0, 1, 1, 0);
                    audioState.progressSampleTime = performance.now();
                    updatePlayhead();
                    if (this.actualSampleRate) {
                      if (this.drawFrequencyScale) {
                        this.redrawFrequencyScaleOverlay();
                      } else {
                        this.clearOverlay();
                      }
                    }
                  }, 10);
                  return nextPalette;
                };
                while (this.nextPalette().toLowerCase() !== palette.toLowerCase()) {
                  // Cycle until we get the desired palette
                }
                this.transformY = (y) => {
                  const top = timelineState.top;
                  const bottom = timelineState.bottom;
                  // Is the incoming y within the clampedRangeY?
                  const maxYZoom =
                    (TEXTURE_HEIGHT / (canvas.height / window.devicePixelRatio)) *
                    MAX_ZOOMED_REGION;
                  const rangeY = top - bottom;
                  const minRangeY =
                    1 / (TEXTURE_HEIGHT / (canvas.height / window.devicePixelRatio));

                  // The input height of the selected region.
                  const clampedRangeY = Math.max(rangeY, minRangeY);
                  const posY = bottom / Math.max(0.000001, 1 - rangeY);
                  const rem = 1 - clampedRangeY;
                  const inBottom = rem * posY;
                  const inTop = inBottom + clampedRangeY;

                  const mMaxZoom = map(clampedRangeY, 1, minRangeY, 1, 1 / maxYZoom);
                  const actualHeight = clampedRangeY * (1 / mMaxZoom);
                  const remainder = 1 - actualHeight;
                  const selectedBottom = remainder * posY;
                  const selectedTop = selectedBottom + actualHeight;

                  const aboveRange = y > inTop;
                  const belowRange = y < inBottom;
                  const inRange = y <= inTop && y >= inBottom;
                  if (inRange) {
                    y = map(y, inBottom, inTop, selectedBottom, selectedTop);
                  } else if (belowRange) {
                    y = map(y, 0, inBottom, 0, selectedBottom);
                  } else if (aboveRange) {
                    y = map(y, inTop, 1.0, selectedTop, 1.0);
                  }
                  return y;
                };
                this.inverseTransformY = (yZeroOne) => {
                  // How much to crop of the top and bottom of the spectrogram (used if the sample rate of the audio was different
                  // from the sample rate the FFT was performed at, since that leaves a blank space at the top)
                  let y = 1 - Math.min(1, Math.max(0, yZeroOne));
                  const top = timelineState.top;
                  const bottom = timelineState.bottom;
                  const maxZoom =
                    1024 / (this.timelineElements.canvas.height / devicePixelRatio);
                  const maxYZoom = maxZoom * 0.8;
                  const minRangeY = 1.0 / maxZoom;
                  const rangeY = top - bottom;
                  const clampedRangeY = Math.max(rangeY, minRangeY);
                  // Prevent divide by zero
                  const posY = bottom / Math.max(0.000001, 1.0 - rangeY);
                  const mMaxZoom = map(
                    clampedRangeY,
                    1.0,
                    minRangeY,
                    1.0,
                    1.0 / maxYZoom
                  );
                  const actualHeight = clampedRangeY * (1.0 / mMaxZoom);
                  const remainder = 1.0 - actualHeight;
                  const selectedBottom = remainder * posY;
                  const selectedTop = selectedBottom + actualHeight;
                  const aboveRange = y > selectedTop;
                  const belowRange = y < selectedBottom;
                  const inRange = y <= selectedTop && y >= selectedBottom;

                  if (inRange) {
                    y = map(y, selectedBottom, selectedTop, bottom, top);
                  } else if (belowRange) {
                    y = map(y, 0.0, selectedBottom, 0.0, bottom);
                  } else if (aboveRange) {
                    y = map(y, selectedTop, 1.0, top, 1.0);
                  }
                  return y;
                };
                let cropAmountTop = 0;
                const clampZeroOne = (x) => Math.max(0, Math.min(1, x));
                const redrawTimescaleOverlay = (
                  ctx,
                  startZeroOne,
                  endZeroOne,
                  duration
                ) => {
                  ctx.save();
                  // Draw a notch every ~second
                  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                  const startTime = startZeroOne * duration;
                  const endTime = endZeroOne * duration;
                  const startSeconds = Math.floor(startTime);
                  const endSeconds = Math.ceil(endTime);
                  const zoomLevel = endZeroOne - startZeroOne;

                  //const distanceBetweenSecondNotches = (startZeroOne + 1) / duration * ctx.canvas.width / devicePixelRatio;

                  // TODO: Fade between.  I guess we want a good way of generalising this pattern of having features fade in at
                  //  various zoom levels.  Maybe show every 10 seconds, then every 5, then every 2, then every 1

                  //console.log("distanceBetweenSecondNotches", distanceBetweenSecondNotches, drawEveryOtherSecond);
                  const tenPx = 10 * devicePixelRatio;
                  ctx.font = `${tenPx}px sans-serif`;
                  ctx.textAlign = "center";
                  let xOpacity = 0.5;
                  let pX = 0;
                  for (let i = startSeconds; i < endSeconds; i += 1) {
                    const oX =
                      mapRange(i / duration, startZeroOne, endZeroOne, 0, 1) *
                      ctx.canvas.width;
                    const distanceBetweenSecondNotches = oX - pX;
                    pX = oX;
                    if (i !== 0) {
                      if (this.drawFrequencyScale) {
                        xOpacity = Math.min(
                          0.5,
                          clampZeroOne(
                            mapRange(
                              oX,
                              ctx.canvas.width - tenPx * 10,
                              ctx.canvas.width,
                              0.5,
                              0
                            )
                          )
                        );
                      }
                      ctx.fillStyle = `rgba(255, 255, 255, ${xOpacity})`;
                      ctx.fillRect(oX, 0, 1, ctx.canvas.height / 2);
                      const minDistanceBetweenSecondNotches = 15 * devicePixelRatio;
                      // TODO: Generalise this

                      // Don't draw labels too close together.
                      const isOdd = i % 2 === 1;
                      if (!isOdd) {
                        const distance = Math.min(
                          30 * devicePixelRatio,
                          distanceBetweenSecondNotches
                        );
                        const opacity = clampZeroOne(
                          mapRange(
                            distance,
                            15 * devicePixelRatio,
                            30 * devicePixelRatio,
                            0,
                            1
                          )
                        );
                        ctx.fillStyle = `rgba(255, 255, 255, ${xOpacity * opacity})`;
                      }
                      // TODO: For clips longer than a minute, should have 1m35s notation?
                      if (oX + tenPx < ctx.canvas.width) {
                        ctx.fillText(`${i}s`, oX, ctx.canvas.height / 2 + tenPx);
                      }
                    }
                    // TODO: Spacing and zoom level of elements should also be proportionate to how close together they are
                    //  because of audio duration.
                    const opacity = clampZeroOne(
                      mapRange(1 - zoomLevel, 0.25, 1, 0, 1)
                    );
                    if (opacity > 0) {
                      ctx.fillStyle = `rgba(255, 255, 255, ${opacity * xOpacity})`;
                      for (let j = 1; j < 10; j += 1) {
                        const oX =
                          mapRange(
                            (i + 0.1 * j) / duration,
                            startZeroOne,
                            endZeroOne,
                            0,
                            1
                          ) * ctx.canvas.width;
                        let h = ctx.canvas.height / 3;
                        if (j === 5) {
                          h += 5 * devicePixelRatio;
                        }
                        ctx.fillRect(oX, 0, 1, h);
                      }
                    }
                  }

                  // for (let i = startSeconds; i < endSeconds; i += 1) {
                  //   const offsetX = ((i / duration)) * ctx.canvas.width;
                  //   console.log(i, offsetX);
                  //   ctx.fillRect(offsetX, 0, 1, ctx.canvas.height);
                  //
                  // }

                  ctx.restore();
                };
                this.redrawTimescaleOverlay = () =>
                  redrawTimescaleOverlay(
                    timescaleOverlayContext,
                    timelineState.left,
                    timelineState.right,
                    audioState.audioDuration
                  );
                this.clearTimescaleOverlay = () => {
                  timescaleOverlayContext.save();
                  timescaleOverlayContext.clearRect(
                    0,
                    0,
                    ctx.canvas.width,
                    ctx.canvas.height
                  );
                };

                this.render = ({detail: {initialRender, force}}) => {
                  if (this.raf) {
                    cancelAnimationFrame(this.raf);
                    this.raf = undefined;
                  }
                  this.raf = requestAnimationFrame(() => {
                    const startZeroOne = timelineState.left;
                    const endZeroOne = timelineState.right;
                    const top = timelineState.top;
                    const bottom = timelineState.bottom;
                    if (
                      (this.deferredWidth &&
                        ctx.canvas.width !== this.deferredWidth) ||
                      (this.deferredHeight &&
                        ctx.canvas.height !== this.deferredHeight)
                    ) {
                      this.resizeCanvases(this.deferredWidth, true);
                      this.timelineElements.container.classList.remove("disabled");
                    } else if (
                      this.deferredWidth &&
                      ctx.canvas.width === this.deferredWidth &&
                      this.deferredHeight &&
                      ctx.canvas.height === this.deferredHeight
                    ) {
                      this.timelineElements.container.classList.remove("disabled");
                    }

                    drawTimelineUI(
                      startZeroOne,
                      endZeroOne,
                      timelineState.currentAction
                    );
                    if (!audioState.playing) {
                      audioState.progressSampleTime = performance.now();
                      updatePlayhead();
                    }

                    // TODO: Move somewhere sensible
                    this.drawTimescale = this.timeScale;
                    this.drawFrequencyScale = this.frequencyScale;
                    if (this.drawTimescale) {
                      redrawTimescaleOverlay(
                        timescaleOverlayContext,
                        startZeroOne,
                        endZeroOne,
                        audioState.audioDuration
                      );
                    }

                    // Render the stretched version
                    renderToContext(ctx, startZeroOne, endZeroOne, top, bottom).then(
                      (s) => {
                        if (!!s) {
                          this.shadowRoot.dispatchEvent(
                            new CustomEvent("render", {
                              bubbles: false,
                              composed: true,
                              cancelable: false,
                              detail: {
                                range: {
                                  begin: startZeroOne,
                                  end: endZeroOne,
                                  min: bottom,
                                  max: top,
                                },
                                context: userOverlayCtx,
                              },
                            })
                          );
                        }
                      }
                    );
                    if (initialRender) {
                      renderToContext(mapCtx, 0, 1, 1, 0);
                    }
                    if (!this.sharedState.interacting || initialRender) {
                      // Render the fine detail of the zoom level and then fill it in when available.
                      renderRange(startZeroOne, endZeroOne, canvas.width, force).then(
                        (rangeCropInfo) => {
                          if (rangeCropInfo && rangeCropInfo.cropAmountTop) {
                            cropAmountTop = rangeCropInfo.cropAmountTop;
                            this.actualSampleRate = rangeCropInfo.actualSampleRate;
                          }
                          if (initialRender) {
                            renderToContext(mapCtx, 0, 1, 1, 0).then(() => {
                              if (
                                this.loadingSpinner &&
                                this.loadingSpinner.parentElement
                              ) {
                                this.loadingSpinner.parentElement.removeChild(
                                  this.loadingSpinner
                                );
                                this.playerElements.playButton.removeAttribute(
                                  "disabled"
                                );
                                this.shadowRoot.dispatchEvent(
                                  new CustomEvent("audio-loaded", {
                                    composed: true,
                                    bubbles: false,
                                    cancelable: false,
                                    detail: {
                                      sampleRate: this.actualSampleRate,
                                      duration: audioState.audioDuration,
                                    },
                                  })
                                );
                                this.endLoad();
                              }
                            });
                          }
                          renderToContext(
                            ctx,
                            timelineState.left,
                            timelineState.right,
                            top,
                            bottom
                          ).then((s) => {
                            if (
                              initialRender &&
                              startTimeOffset !== 0 &&
                              endTimeOffset !== 1
                            ) {
                              // NOTE: If we're doing an initial render at a zoomed in portion, we need to make sure we create
                              //  the full range image first.
                              setInitialZoom(
                                startTimeOffset,
                                endTimeOffset,
                                1,
                                0,
                                initialRender,
                                true
                              );
                            }

                            if (!!s) {
                              this.shadowRoot.dispatchEvent(
                                new CustomEvent("render", {
                                  bubbles: false,
                                  composed: true,
                                  cancelable: false,
                                  detail: {
                                    range: {
                                      begin: startZeroOne,
                                      end: endZeroOne,
                                      min: bottom,
                                      max: top,
                                    },
                                    context: userOverlayCtx,
                                  },
                                })
                              );
                            }
                          });
                        }
                      );
                    }
                  });
                };
                initAudio(
                  this.playerElements,
                  audioFloatData,
                  audioState
                );
                this.removePlaybackFrequencyBandPass();
                if (audioState.playing || audioState.audioProgressZeroOne !== 0) {
                  this.pause();
                }
                // Initial render
                this.render({detail: {initialRender: true, force: true}});
                // TODO: Animate to region of interest could be replaced by reactive setting of :start :end props?
                this.resizeInited = true;
              }
            }
          } catch (e) {
            // Failed to load audio, should show an error
            console.warn("aborted?", e);
          }
        }
      })();
    }

    beginLoad() {
      if (!this.loadingSpinner.parentElement) {
        this.timelineElements.spectrogramContainer.appendChild(
          this.loadingSpinner
        );
      }
      this.timelineElements.container.classList.add("loading");
    }

    endLoad() {
      this.timelineElements.container.classList.remove("loading");
    }

    showErrorMessage(error) {
      if (
        this.loadingSpinner &&
        this.loadingSpinner.parentElement
      ) {
        this.loadingSpinner.parentElement.removeChild(
          this.loadingSpinner
        );
      }
      this.timelineElements.container.classList.add("error");
      this.timelineElements.container.querySelector(".error-message").innerHTML = `Error: ${error}`;
      this.endLoad();
    }

    init() {
      // TODO: Maybe pass in min/max frequency bounds, so that the view is restricted to AOI?
      // TODO: Get height dynamically from attributes, and respond to changes in height.
      const lazyLoad = this.hasAttribute("lazy");
      const totalHeight = this.height || 360;
      this.timelineHeight = Math.min(60, Math.max(44, totalHeight - 200));
      this.spectrogramHeight = totalHeight - this.timelineHeight;

      const src = this.getAttribute("src");
      const root = this.shadowRoot;
      if (!this.inited) {
        root.appendChild(template.content.cloneNode(true));
      }

      const container = root.getElementById("container");
      const spectrogramContainer = root.getElementById("spectrogram-container");
      const canvasContainer = root.getElementById("canvas-container");
      const miniMapContainer = root.getElementById("mini-map");
      const mapCanvas = root.getElementById("map-canvas");
      const canvas = root.getElementById("spectrogram-canvas");
      const overlayCanvas = root.getElementById("spectastiq-overlay-canvas");
      const timescaleCanvas = root.getElementById(
        "spectastiq-timescale-overlay-canvas"
      );
      const userOverlayCanvas = root.getElementById("user-overlay-canvas");
      const playheadCanvas = root.getElementById("playhead-canvas");
      const timelineUICanvas = root.getElementById("timeline-ui-canvas");

      if (!(src && !this.inited)) {
        container.classList.add("no-src");
        // NOTE: No audio src, show ability to load from disk.
        const selectUserFileBtn = root.querySelector(".select-user-file-btn");
        const fileInput = root.querySelector(".select-user-file-input");
        selectUserFileBtn.addEventListener("click", () => {
          fileInput.click();
        });
        fileInput.addEventListener('change', (e) => {
          if (e.target.files && e.target.files.length !== 0) {
            root.getElementById("container").classList.remove("no-src");
            const file = e.target.files[0];
            this.localSrc = e.target.files[0].name;
            this.loadSrc(URL.createObjectURL(file));
          }
        });
      }

      if (!this.loadingSpinner) {
        this.loadingSpinner = root.getElementById("loading-spinner");
        this.loadingSpinner.parentElement.removeChild(this.loadingSpinner);
      }
      if (!this.progressBar) {
        this.progressBar = root.getElementById("progress-bar");
        this.progressBar.parentElement.removeChild(this.progressBar);
      }
      const mainPlayheadCanvas = root.getElementById("main-playhead-canvas");
      const controls = root.getElementById("controls");
      const playButton = root.getElementById("play-button");

      this.timelineElements = {
        mapCanvas,
        canvas,
        canvasContainer,
        miniMapContainer,
        userOverlayCanvas,
        overlayCanvas,
        timescaleCanvas,
        timelineUICanvas,
        mainPlayheadCanvas,
        container,
        spectrogramContainer,
      };

      this.playerElements = {
        playheadCanvas,
        mainPlayheadCanvas,
        playButton,
        canvas,
        overlayCanvas,
        playheadCanvasCtx: playheadCanvas.getContext("2d"),
        mainPlayheadCanvasCtx: mainPlayheadCanvas.getContext("2d"),
      };
      const resizeCanvas = (canvas, width, height, forReal = true) => {
        canvas.style.height = `${height}px`;
        canvas.style.width = `${width}px`;
        // NOTE: Defer resizing the backing canvas until we actually want to draw to it, this makes resizes look better.
        if (!this.resizeInited || forReal) {
          canvas.height = height * devicePixelRatio;
          canvas.width = width * devicePixelRatio;
        } else {
          this.deferredWidth = width;
          this.deferredHeight = height;
        }
      };
      overlayCanvas.addEventListener("interaction-begin", () => {
        controls.classList.add("disabled");
        this.sharedState.interacting = true;
        const startZeroOne = timelineState.left;
        const endZeroOne = timelineState.right;
        // TODO: Await requestAnimationFrame?
        // TODO: Set timeout in case we're interacting but not moving?
        drawTimelineUI(startZeroOne, endZeroOne, timelineState.currentAction);
      });
      overlayCanvas.addEventListener("interaction-target-changed", () => {
        // Canvas-based hit areas changed, so redraw handles for hover states etc.
        const startZeroOne = timelineState.left;
        const endZeroOne = timelineState.right;
        drawTimelineUI(startZeroOne, endZeroOne, timelineState.currentAction);
        updatePlayhead();
      });
      overlayCanvas.addEventListener("interaction-end", () => {
        controls.classList.remove("disabled");
        this.sharedState.interacting = false;
        this.render &&
        this.render({detail: {initialRender: false, force: true}});
      });

      const clearOverlay = () => {
        const overlayCtx = overlayCanvas.getContext("2d");
        overlayCtx.clearRect(
          0,
          0,
          overlayCtx.canvas.width,
          overlayCtx.canvas.height
        );
      };
      this.clearOverlay = clearOverlay;

      const redrawFrequencyScaleOverlay = (state, actualSampleRate) => {
        const ctx = overlayCanvas.getContext("2d");
        ctx.save();
        const isDarkTheme = state.isDarkTheme;
        state.textMeasurementCache = state.textMeasurementCache || {};
        const maxFreq = actualSampleRate / 2;
        const pixelRatio = window.devicePixelRatio;
        ctx.font = `${10 * pixelRatio}px sans-serif`;
        const divisions = Math.ceil(maxFreq / 1000) + 1;
        const divisionColor = isDarkTheme
          ? "rgba(255, 255, 255, 0.1)"
          : "rgba(0, 0, 0, 0.1)";
        const textColor = isDarkTheme
          ? "rgba(255, 255, 255, 0.5)"
          : "rgba(0, 0, 0, 0.85)";
        //start at bottom?
        ctx.strokeStyle = divisionColor;
        ctx.lineWidth = 1;
        ctx.textAlign = "right";
        ctx.textBaseline = "bottom";
        ctx.fillStyle = textColor;
        const label = "kHz";
        const labelX = ctx.canvas.width - 4 * devicePixelRatio;
        const kHzLabelY = ctx.canvas.height - 4 * devicePixelRatio;
        ctx.fillText(label, labelX, kHzLabelY);
        const cacheKey = `${label}_${pixelRatio}`;
        const textHeight =
          state.textMeasurementCache[cacheKey] ||
          ctx.measureText(label).actualBoundingBoxAscent;
        state.textMeasurementCache[cacheKey] = textHeight;

        let prevY = (kHzLabelY - textHeight * 0.5) / pixelRatio;
        const minYOffsetFromMargin = Math.abs(
          prevY - ctx.canvas.height / pixelRatio
        );
        for (let i = divisions; i >= 0; i--) {
          const yy = i / divisions;
          const yyy = this.transformY(1 - yy);
          let y = ((1 - yyy) * ctx.canvas.height) / pixelRatio;
          if (prevY - y > 15) {
            ctx.strokeRect(
              0,
              y * pixelRatio,
              ctx.canvas.width - 25 * pixelRatio,
              0
            );
            ctx.textBaseline = "middle";
            const thisFrequency = Math.round((1 - yy) * maxFreq) / 1000;
            const label = `${thisFrequency.toFixed(1).toLocaleString()}`;
            // NOTE: Measure text takes a fair bit on time on chrome on lower powered android devices; cache measurements.
            const cacheKey = `${label}_${pixelRatio}`;
            const textHeight =
              state.textMeasurementCache[cacheKey] ||
              ctx.measureText(label).actualBoundingBoxAscent;
            state.textMeasurementCache[cacheKey] = textHeight;
            const overshootBottom = y + (textHeight + 5 * pixelRatio) * 0.5;
            const overshotBottom =
              overshootBottom >= ctx.canvas.height / pixelRatio;
            if (overshotBottom) {
              ctx.textBaseline = "bottom";
              y -= 2 * pixelRatio;
            }
            // NOTE: fillText is also slow on low-end devices, consider caching text and blitting.
            if (y * pixelRatio > 0) {
              ctx.fillText(
                label,
                ctx.canvas.width - 4 * pixelRatio,
                Math.max(minYOffsetFromMargin * pixelRatio, y * pixelRatio)
              );
              prevY = y;
            }
          }
        }
        ctx.restore();
      };

      overlayCanvas.addEventListener("range-change", (e) => {
        this.render && this.render(e);
      });
      let prevMax = 0;
      let prevMin = 1;
      this.shadowRoot.addEventListener("render", (e) => {
        const yRangeChanged =
          e.detail.range.min !== prevMin || e.detail.range.max !== prevMax;
        prevMax = e.detail.range.max;
        prevMin = e.detail.range.min;
        if (yRangeChanged) {
          this.drawFrequencyScale && clearOverlay();
          this.drawFrequencyScale &&
          redrawFrequencyScaleOverlay(timelineState, this.actualSampleRate);
        }
      });
      this.shadowRoot.addEventListener("audio-loaded", (e) => {
        container.classList.add("audio-loaded");
        this.drawFrequencyScale && clearOverlay();
        this.drawFrequencyScale &&
        redrawFrequencyScaleOverlay(timelineState, e.detail.sampleRate);
      });
      overlayCanvas.addEventListener("double-click", async (e) => {
        if (this.applicationHandlesDoubleClick) {
          this.shadowRoot.dispatchEvent(new CustomEvent("double-click", {
            detail: e.detail,
            composed: true,
            bubbles: false,
            cancelable: false,
          }));
        } else {
          // If there's a selected track, should we stop at the end of it?
          await play(e.detail.audioOffsetZeroOne);
        }
      });

      const timeline = initTimeline(
        this.shadowRoot,
        this.sharedState,
        this.timelineElements
      );
      const {
        drawTimelineUI,
        timelineState,
        setInitialZoom,
        animateToRange,
        getMaxXZoom,
        getMaxYZoom,
        resetYZoom,
      } = timeline;
      this.timeline = {
        drawTimelineUI,
        redrawFrequencyScaleOverlay,
        timelineState,
        setInitialZoom,
        animateToRange,
        getMaxXZoom,
        getMaxYZoom,
        resetYZoom,
      };

      const player = initAudioPlayer(
        this.shadowRoot,
        this.sharedState,
        this.timeline.timelineState,
        this.playerElements
      );
      const {
        audioState,
        updatePlayhead,
        setPlaybackOffset,
        setGain,
        setBandPass,
        startPlayheadDrag,
        endPlayheadDrag,
        dragLocalPlayhead,
        dragGlobalPlayhead,
        removeBandPass,
        play,
        pause,
      } = player;

      // TODO: Probably move audio progress to sharedState
      timelineState.audioState = player.audioState;
      timelineState.startPlayheadDrag = startPlayheadDrag;
      timelineState.endPlayheadDrag = endPlayheadDrag;
      timelineState.dragLocalPlayhead = dragLocalPlayhead;
      timelineState.dragGlobalPlayhead = dragGlobalPlayhead;
      this.audioPlayer = {
        audioState,
        updatePlayhead,
        setPlaybackOffset,
        setBandPass,
        removeBandPass,
        startPlayheadDrag,
        endPlayheadDrag,
      };

      this.play = play;
      this.pause = pause;
      this.setGain = setGain;

      this.animateToRegionOfInterest = async (start, end, min, max) => {
        const initialStart = timelineState.left;
        const initialEnd = timelineState.right;
        const initialTop = timelineState.top;
        const initialBottom = timelineState.bottom;
        await animateToRange(
          initialStart,
          initialEnd,
          initialTop,
          initialBottom,
          start,
          end,
          max,
          min,
          200,
          (left, right, top, bottom, final) => {
            setInitialZoom(left, right, top, bottom, false, final);
          }
        );
      };

      this.setPlaybackFrequencyBandPass = (minFreq, maxFreq) => {
        setBandPass(minFreq, maxFreq);
      };
      this.removePlaybackFrequencyBandPass = () => removeBandPass();

      this.selectRegionOfInterest = async (start, end, min, max) => {
        {
          const centerX = start + (end - start) * 0.5;
          if (audioState.audioContext.state !== "running") {
            // If we start zooming to a region before the context is running, things break.
            await audioState.audioContext.resume();
          }
          const maxXZoom = getMaxXZoom();
          const pRange = (end - start) * 1.1;
          const paddedRange = Math.max(1 / maxXZoom, pRange);
          const range = paddedRange / 2;
          start = Math.max(centerX - range, 0);
          if (centerX - range < 0) {
            end = centerX + range + Math.abs(centerX - range);
          } else {
            end = centerX + range;
          }
          start = Math.max(0, start);
          end = Math.min(1, end);
        }
        {
          const maxYZoom = getMaxYZoom();
          // Make sure max - min is at least 1/maxYZoom;
          const minZoomYHeight = 1 / maxYZoom;
          let range = max - min;
          if (range < minZoomYHeight) {
            const centerY = min + range * 0.5;
            min = centerY - minZoomYHeight * 0.5;
            max = centerY + minZoomYHeight * 0.5;
            min = Math.max(0, min);
            max = Math.min(1, max);
            range = max - min;
            if (min === 0 && range < minZoomYHeight) {
              max = minZoomYHeight;
            } else if (max === 1 && range < minZoomYHeight) {
              min = 1 - minZoomYHeight;
            }
          }
        }

        this.timelineElements.overlayCanvas.dispatchEvent(
          new Event("interaction-begin")
        );
        await this.animateToRegionOfInterest(start, end, min, max);
        this.timelineElements.overlayCanvas.dispatchEvent(
          new Event("interaction-end")
        );
      };
      this.resetYZoom = resetYZoom;
      this.redrawFrequencyScaleOverlay = () =>
        redrawFrequencyScaleOverlay(timelineState, this.actualSampleRate);

      this.enterCustomInteractionMode = () => {
        timelineState.customInteractionMode = true;
        this.timelineElements.spectrogramContainer.classList.add(
          "custom-interaction-mode"
        );
      };
      this.exitCustomInteractionMode = () => {
        timelineState.customInteractionMode = false;
        this.timelineElements.spectrogramContainer.classList.remove(
          "custom-interaction-mode"
        );
      };
      this.beginCustomInteraction = () => {
        timelineState.inCustomInteraction = true;
      };
      this.endCustomInteraction = () => {
        timelineState.inCustomInteraction = false;
      };

      this.resizeCanvases = (resizedWidth, forReal) => {
        const width = resizedWidth || container.getBoundingClientRect().width;
        this.timelineElements.canvasContainer.style.height = `${this.spectrogramHeight}px`;
        this.timelineElements.miniMapContainer.style.height = `${this.timelineHeight}px`;
        const initialWidth = this.timelineElements.canvas.width;
        resizeCanvas(
          this.timelineElements.canvas,
          width,
          this.spectrogramHeight,
          forReal
        );
        resizeCanvas(
          this.timelineElements.timescaleCanvas,
          width,
          Math.max(20, Math.min(30, this.spectrogramHeight / 10)),
          true
        );
        resizeCanvas(
          this.timelineElements.overlayCanvas,
          width,
          this.spectrogramHeight,
          true
        );
        resizeCanvas(
          this.timelineElements.userOverlayCanvas,
          width,
          this.spectrogramHeight,
          true
        );

        resizeCanvas(
          this.timelineElements.mapCanvas,
          width,
          this.timelineHeight,
          forReal
        );
        resizeCanvas(
          this.timelineElements.timelineUICanvas,
          width,
          this.timelineHeight,
          true
        );

        resizeCanvas(
          this.playerElements.mainPlayheadCanvas,
          width,
          this.spectrogramHeight,
          true
        );
        resizeCanvas(
          this.playerElements.playheadCanvas,
          width,
          this.timelineHeight,
          true
        );
        let didChangeWidth = false;
        width * devicePixelRatio !== this.timelineElements.canvas.width;
        if (forReal) {
          didChangeWidth =
            this.deferredWidth &&
            this.timelineElements.canvas.width ===
            this.deferredWidth * devicePixelRatio &&
            this.deferredWidth !== initialWidth;
          this.deferredWidth = undefined;
          this.deferredHeight = undefined;
        }

        const wasTriggeredByResizeEvent = !!resizedWidth;
        if (wasTriggeredByResizeEvent && !!this.resizeInited) {
          {
            const startZeroOne = timelineState.left;
            const endZeroOne = timelineState.right;
            drawTimelineUI(startZeroOne, endZeroOne, timelineState.currentAction);
            if (this.actualSampleRate) {
              this.drawFrequencyScale && clearOverlay();
              this.drawFrequencyScale &&
              redrawFrequencyScaleOverlay(timelineState, this.actualSampleRate);
            }
            if (!audioState.playing) {
              audioState.progressSampleTime = performance.now();
              updatePlayhead();
            }
          }
          this.sharedState.interacting = true;
          clearTimeout(this.sharedState.interactionTimeout);
          this.timelineElements.container.classList.add("disabled");
          this.sharedState.interactionTimeout = setTimeout(() => {
            // TODO: We only want to invalidate the caches if the *backing* size of the spectrogram has changed,
            //  and it needed to be re-rendered.  Otherwise just draw what we have again with no delay.
            //  Worth noting though that our webgl canvases *do* need to be resized at some point, and at that point
            //  we need to re-upload the textures, which can cause a hitch
            if (didChangeWidth) {
              this.invalidateCanvasCaches && this.invalidateCanvasCaches();
              this.renderRange &&
              this.renderRange(0, 1, canvas.width, true).then(() => {
                this.render({detail: {initialRender: true, force: true}});
              });
            } else {
              this.render({detail: {initialRender: true, force: true}});
            }
            this.sharedState.interacting = false;
          }, 300);
        }
      };
      const resizeObserver = new ResizeObserver((entries) => {
        // We'll defer resizing the spectrogram backing canvas until a new spectrogram has been created at the new
        // width and is ready to render.
        this.resizeCanvases(entries[0].contentRect.width, false);
      });
      resizeObserver.observe(container);
      if (lazyLoad) {
        const intersectionObserver = new IntersectionObserver((intersection) => {
          if (intersection[0].isIntersecting && src && src !== "null" && src !== "undefined") {
            this.loadSrc(src);
            intersectionObserver.disconnect();
          }
        }, {
          rootMargin: '50px',
          threshold: 0.1
        });
        intersectionObserver.observe(container);
      } else {
        // Initial attributeChangedCallback happens before connectedCallback, so need to load src after initial one-time setup.
        if (src && src !== "null" && src !== "undefined") {
          // NOTE: Vue initially passes `null` or `undefined` to src, which gets stringified.
          this.loadSrc(src);
        }
      }
    }
  }
  if (!customElements.get("spectastiq-viewer")) {
    customElements.define("spectastiq-viewer", Spectastiq);
  }

  return Spectastiq;

})();
